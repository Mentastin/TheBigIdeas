code smell

readability (clarity)

Magic numbers

SOLID, STUPID

DRY

Object calisthenics:
\begin{enumerate}
\item Only one level of indentation per method
\item Do not use else
\item Wrap primitive types (especially if they contain behavior)
\item Only one method call per line.
\item Do not abbreviate
\item Keep classes small: about 10 methods of 10 lines each.
\item Limit your instance variables to two.
\item Use first class collections
\item Don't use getters and setters. Too generic.
\end{enumerate}

\section{Development processess}
\subsection{Iterative and waterfall processes}
The essential difference is how a project gets broken up into smaller chunks. To build software you might have to do certain activities: requirements analysis, design, coding and testing.

\begin{itemize}
\item The \udef{waterfall} style breaks down the project based on those activities, e.g. having 2-month analysis, 4-month design, 3-month coding and 3-month testing phases.
\item The \udef{iterative} styles breaks down a project by subsets of functionality. This means performing all four activities so you have a systems that works well with only a part of the functionality, then performing all four activities again to add more functionality. And again, and again.

A common technique is \udef{time boxing} where the scope of each iteration is determined by time, not feature set.

At the end of each iteration an \textbf{iteration retrospective} may be held. A good way to do this is to make a list with three categories:
\begin{itemize}
\item \textit{Keep:} things that worked well that you want to ensure you continue to do.
\item \textit{Problems:} areas that aren't working well.
\item \textit{Try:} changes to your process to improve it.
\end{itemize}
\end{itemize}

In practice, of course, there is some overlap. With waterfall development there are often backflows: during coding and testing it may be necessary to revisit analysis and design. These backflows should be minimised as much as possible.

With iteration there is usually some form of exploration activity and analysis before the true iteration begins. At the end there is usually a global stabilisation period to iron out bugs. Also other activities, such as user training, may not be part of the iteration.

There are also hybrid processes, such as first doing analysis and high-level design in waterfall style and then dividing coding and testing into iterations.

\begin{params}
Many people agree pure waterfall is bad, but it is still most common in industry. Often people claim to be working iteratively when in fact they doing waterfall. Common symptoms include
\begin{itemize}
\item ``We are doing one analysis iteration followed by two design iterations.''
\item ``This iteration's code is very buggy, but we'll clean it up at the end.''
\end{itemize}
\end{params}

TODO: rework.
The iterative approach explicitly assumes that existing code will be reworked and deleted. This process can be made more efficient with
\begin{itemize}
\item Automated regression testing
\item Refactoring
\item Continuous integration
\end{itemize}

\subsection{Predictive and adaptive planning}
With \udef{predictive planning} a project has two phases. The first is coming up with plans and is difficult to predict, but the second is much more predictable because the plans are in place. 

The problem is that often requirements change. This is called \udef{requirements churn}. To combat this you could spend more time planning, but often requirements churn is unavoidable. In such cases one needs to settle for \udef{adaptive planning}, where everything is constantly reevaluated.

\subsection{Agile processes}
The Manifesto for Agile Software Development (\url{https://agilemanifesto.org/}) states the following values:
\begin{displayquote}
{\Large Individuals and interactions} over processes and tools \\
{\Large Working software} over comprehensive documentation \\
{\Large Customer collaboration} over contract negotiation \\
{\Large Responding to change} over following a plan
\end{displayquote}
As well as the following principles:
\begin{displayquote}
\begin{enumerate}
\item Our highest priority is to satisfy the customer
through early and continuous delivery
of valuable software.
\item Welcome changing requirements, even late in
development. Agile processes harness change for
the customer's competitive advantage.
\item Deliver working software frequently, from a
couple of weeks to a couple of months, with a
preference to the shorter timescale.
\item Business people and developers must work
together daily throughout the project.
\item Build projects around motivated individuals.
Give them the environment and support they need,
and trust them to get the job done.
\item The most efficient and effective method of
conveying information to and within a development
team is face-to-face conversation.
\item Working software is the primary measure of progress.
\item Agile processes promote sustainable development.
The sponsors, developers, and users should be able
to maintain a constant pace indefinitely.
\item Continuous attention to technical excellence
and good design enhances agility.
\item Simplicity -- the art of maximizing the amount
of work not done -- is essential.
\item The best architectures, requirements, and designs
emerge from self-organizing teams.
\item At regular intervals, the team reflects on how
to become more effective, then tunes and adjusts
its behavior accordingly.
\end{enumerate}
\end{displayquote}

Agile processes are strongly adaptive and very much people-oriented. They also tend to use short, time-boxed iterations with little weight attached to documents and ceremony. For this reason they are often characterised as \textbf{lightweight} (this is a consequence of adaptivity and people orientation).
\subsubsection{Extreme programming (XP)}
\subsubsection{Scrum}
\subsubsection{Feature driven development (FDD)}
\subsubsection{Crystal}
\subsubsection{Dynamic systems development method (DSDM)}

\subsection{Rational unified processes (RUP)}
RUP is a project framework: the first step is to choose a development case, i.e. the process used in the project.

All RUP projects follow four phases:
\begin{itemize}
\item Inception
\item Elaboration
\item Construction
\item Transition
\end{itemize}
RUP is only compatible with an iterative work flow.

\section{Design documents and documentation}
Detailed documentation generated from the code and external documentation. External documentation should be comprehensible, not comprehensive.

Document design alternatives that were not chosen and why not.

\section{Coding styles}
defensive, total, 
design by contract
\section{Testing}
Difference in style
\subsection{Unit testing}
\section{Coding in a team}
I have very little experience with this. This section is mostly just a place for me to put tips I have heard for future reference.

\section{Version control}
\subsection{Git}
\subsection{Subversion}

\section{Benchmarking}
\section{Optimization}
Precompute (integral pictures)

Only worry about bottlenecks. Premature optimization is the root of all evil.

Inner loops

Timing analysis