\section{Introduction: what and why?}
In computer science types provide a lightweight formal method for theoretical analysis of some aspects of computer programs.

They are related to the broader mathematical field of type theory. Type theory was originally conceived as a way to avoid logical paradoxes, like Russell's paradox.

The name ``type system'' can refer to a large number of different systems, making it difficult to give a general definition. (TODO cite Pierce) suggests the following

\begin{displayquote}
A type system is a tractable syntactic method for proving the absence of certain program behaviors by classifying phrases according to the kinds of values they compute.
\end{displayquote}

A type system can be seen as a kind of static approximation of the runtime behaviour of the program. Sometimes the moniker ``static'' is explicitly added, to distinguish it from dynamic typing, which is arguably a misnomer (and should maybe be referred to as dynamic checking, but the usage is standard).

Most type systems can only guarantee that well-typed programs are free from certain types of errors. However in principle it should be possible to make type annotations encode an arbitrary specification. In this case the type checker would become a \textit{proof} checker.

Type checking is / should be automatic. Here we are interested in practical applications, so we are most interested in methods that are not just automatable in principle, but actually have known, efficient algorithms.

\subsection{What type systems are good for}
\begin{enumerate}
\item \textbf{Detecting errors}. Not only trivial mental slips, but also deeper conceptual errors.
\item \textbf{Abstraction}. Interfaces can be seen the the ``type of the module''.
\item \textbf{Documentation}. Types help make clear what variables and parameters are supposed to do. This documentation is built into the program and thus cannot go out of date.
\item \textbf{Language safety}. This concept is not well defined, but we can say that a safe language \textit{protects its own abstractions}. In particular it means programmers can not (unwittingly) use data that was supposed to be a string as a number or write past the end of an array. In extreme cases a program may damage the data structures of the runtime system and itself. One of the ways to achieve language safety is using is having a good type system, although often some sort of dynamic checking (e.g. for array bounds) is also needed.

There are also some other ways to view language safety:
\begin{itemize}
\item One may view a safe language as one that is completely defined by its manual. A language like C is not safe because,e.g., pointer arithmetic depends on the details of memory management. This is compiler specific and not part of the specification.
\item Another perspective on language safety is given by defining trapped and untrapped run-time errors. Trapped errors cause execution to stop immediately, while computation can continue with untrapped errors.

A safe language is then one that prevents untrapped errors at run time.
\end{itemize}
\item \textbf{Efficiency}. By giving the compiler more information, it can optimise more easily. Also static type checking is generally much faster than dynamic checking for guaranteeing language safety.
\end{enumerate}


\section{Untyped systems}

\section{Simple types}

\section{Subtyping}

\section{Recursive types}

\section{Polymorphism}

\section{Higher-order systems}