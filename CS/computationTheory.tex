\section{Abstract machines}
\begin{definition}
An \udef{abstract machine} is a function $M: I\times T \to S$. Where
\begin{itemize}
\item $I$ is a set of possible inputs;
\item $T$ is a set that is supposed to index the progress of the machine; suppose it is a complete lattice;
\item $S$ is a set of possible states of the machine.
\end{itemize}
\end{definition}

\subsection{Halting time and the halting problem}
\begin{definition}
Let $M: I\times T \to S$ be an abstract machine, $A \subseteq S$ a subset of states called \udef{accepted states} and $i\in I$ an input.

The \udef{halting time} is defined as
\[ h(i,A, M) \defeq \inf\setbuilder{t}{M(i,t) \in A}. \]
It is possible that $h(i,A, M) = \top \in T$. In this case the machine never halts.
\end{definition}

\subsection{Complexity}
\subsubsection{Space complexity}
\begin{definition}
Let  $M: I\times T \to S$ be an abstract machine, $A \subseteq S$ a subset of accepted states and $i\in I$ an input.

Let $c_S: S\to \R^+$ be a function called the \udef{(spatial) cost function}.

The \udef{space complexity} of $M$ with input $i$ is defined as
\[ \max_{t\leq h(i,A,M)} c_S(M(i,t)). \]
TODO: worst case, best case, average case.
\end{definition}

\subsubsection{Time complexity}
\begin{definition}

\end{definition}

\section{Automata}
\begin{definition}
An \udef{automaton} is an abstract machine $M: I\times T \to S$ such that
\begin{itemize}
\item $I$ is the Kleene closure $\Sigma^*$ of some finite set $\Sigma$, called the \udef{input alphabet};
\item $T = \N$;
\item $M$ is of the form $(i,n)\mapsto \left(\prod_{i=0}^{\len(i)}\delta(\cdot, i(n))\right)(s_0)$ for some
\begin{itemize}
\item \udef{transition function} $\delta: S \times \Sigma \to S$;
\item \udef{initial state} $s_0$.
\end{itemize}
\end{itemize}
We also fix a set of accepted states $A\subseteq S$.


\end{definition}

\section{Models of computation}
Stack machine (0-operand machine)
Accumulator machine (1-operand machine)
Register machine (2,3,... operand machine)

Expressive power

\url{http://cs.brown.edu/people/jsavage/book/pdfs/ModelsOfComputation.pdf}

\subsection{Sequential models}
\subsubsection{Finite state machines}
\subsubsection{Pushdown automata}
\subsubsection{Turing machine}
\subsection{Register machines}
\subsubsection{Counter machine}
\subsubsection{Pointer machine}
\subsubsection{Random-access machine (RAM)}
\subsubsection{Random-access stored-program machine model (RASP)}
\subsection{Functional models}
\subsubsection{Lambda calculus}
\subsubsection{Recursive calculus}
\subsubsection{Combinatory logic}
\subsubsection{Abstract rewriting systems}
\subsection{Concurrent models}
\subsubsection{Cellular automata}
\subsubsection{Kahn process networks}
\subsubsection{Petri nets}
\subsubsection{Synchronous data flow}
\subsubsection{Interaction nets}
\subsubsection{Actor model}
\section{Computability theory}
\section{Computational complexity}
Depends on model of computation. TODO Cell-probe model