\chapter{Abstract rewriting systems}
\section{Definitions}
\begin{definition}
An \udef{(abstract) rewriting system} is a pair $\sSet{X, R}$ where
\begin{itemize}
\item $X$ is a set;
\item $R$ is a binary relation on $X$. The elements of $R$ are called \udef{(rewriting) rules}.
\end{itemize}
Let $x,y\in X$. Then we call
\begin{itemize}
\item $y$ a \udef{successor} of $x$ if $xR^+y$;
\item $y$ a \udef{direct successor} of $x$ if $xRy$.
\end{itemize}
We say
\begin{itemize}
\item $x$ is \udef{reducible} if there exists $y$ such that $x\mathrel{R}y$;
\item $x$ is \udef{irreducible} or \udef{in normal form} if $x$ is not reducible;
\item $y$ is a \udef{normal form of} $x$ if $xR^*y$ and $y$ is in normal form.
\end{itemize}
We say
\begin{itemize}
\item $x$ and $y$ are \udef{joinable} if $x\big(R^*;(R^\transp)^*\big)y$. We write $x \joins y$.
\end{itemize}
\end{definition}

\subsection{Properties of rewriting systems}
\begin{definition}
Let $\sSet{X, R}$ be a rewriting system. This system is called
\begin{itemize}
\item \udef{terminating} if $R^+$ is satisfies the ascending chain condition;
\item \udef{normalising} if every element has a normal form;
\end{itemize}
it is said to
\begin{itemize}
\item have the \udef{Church-Rosser} property if $\forall x,y\in X: \; x\mathrel{\equiv_R}y \implies x \joins y$;
\item be \udef{confluent} if $\forall x,y_1, y_2\in X: \; \big(x\mathrel{R^*}y_1\big) \land \big(x\mathrel{R^*}y_2\big) \implies y_1 \joins y_2$;
\item be \udef{semi-confluent} if $\forall x,y_1, y_2\in X: \; \big(x\mathrel{R}y_1\big) \land \big(x\mathrel{R^*}y_2\big) \implies y_1 \joins y_2$.
\end{itemize}
The system is called
\begin{itemize}
\item \udef{convergent} if it is both confluent and terminating.
\end{itemize}
\end{definition}
Note that the Church-Rosser property is equivalent to
\[ \forall x,y\in X: \; x\mathrel{\equiv_R}y \iff x \joins y. \]

A rewriting system $\sSet{X, R}$ is normalising if and only if the associated tree $\sSet{T_R, \sqsubseteq}$ is coatomic. The normal forms are the coatoms.



\begin{proposition}
Any terminating relation is normalising, but the converse is not true.
\end{proposition}
This result assumes DC.
\begin{proof}
Let $\sSet{X, R}$ be a non-normalising rewriting system. Then we can find $u\in T_R$ such that $u{\sqsubseteq}$ does not contains a terminal node. Thus ${\sqsubseteq}u \cup u{\sqsubseteq}$ is a pruned tree. By \ref{ZornEquivalentsDC} it contains an infinite branch. Thus $T_R$ contains an infinite branch and $R$ is not terminating.

The following example shows that the converse is not true.
\end{proof}

\begin{example}
Confluent, normalising and asymmetric, but not terminating.
\[ \begin{tikzcd}
\bullet \rar \dar & \bullet \rar \ar[dl] & \bullet \rar \ar[dll] & \hdots \\
\bullet
\end{tikzcd} \]
\end{example}


\subsubsection{Diagrams for rewriting systems}
\begin{definition}
Let $\sSet{X,R}$ be a rewriting system. An \udef{RS-diagram} is a diagram with nodes and arrows between the nodes.
\begin{itemize}
\item Each node is labeled either by a variable (in which case we call it a variable node) or a constant (in which case we call it a constant node).
\item A constant node is drawn in a box.
\item An unlabeled node is implicitly a variable node.
\end{itemize}
Each arrow represents a proposition (with two unbounded variables):
\begin{itemize}
\item $x\to y$ represents $xRy$;
\item $x\leftrightarrow y$ represents $x(R\cup R^\transp)y$;
\item $x\overset{?}{\to}y$ represents $x(R\cup \id_X)y$;
\item $x\overset{+}{\to}y$ represents $xR^+y$;
\item $x\overset{*}{\to}y$ represents $xR^*y$;
\item $x\overset{n}{\to}y$ for some $n\in \N$ represents $xR^ny$;
\item $x\overset{-1}{\to}y$ represents $xR^\transp y$;
\item $x\overset{?}{\leftrightarrow}y$ represents $x(R\cup R^\transp \cup \id_X)y$;
\item $x\overset{+}{\leftrightarrow}y$ represents $x(R\cup R^\transp)^+y$;
\item $x\overset{*}{\leftrightarrow}y$ represents $x(R\cup R^\transp)^*y$;
\item $x\overset{n}{\leftrightarrow}y$ for some $n\in \N$ represents $x(R\cup R^\transp)^ny$.
\end{itemize}
Each arrow may be solid or dashed. Let
\begin{itemize}
\item $x_0, \ldots x_n$ be the variables that label variable nodes connected by at least one solid arrow;
\item $y_0,\ldots y_n$ the other variables in the diagram;
\item $A_0, \ldots, A_k$ the propositions represented by the solid arrows;
\item $B_0, \ldots, B_l$ the propositions represented by the dashed arrows.
\end{itemize}
Then the diagram represents the proposition
\[ \forall x_0, \ldots x_n \in X: \Big(A_0\land \ldots\land A_k \land\textbf{TRUE} \; \implies\; \exists y_0,\ldots y_n: (B_0\land \ldots \land B_l) \lor\textbf{FALSE} \Big). \]
\end{definition}

The addition of the constants TRUE and FALSE is for when a diagram contains either no solid or no dashed arrows.

\begin{itemize}
\item If the diagram contains no dashed arrows, then it is trivially true.
\item If the diagram contains no solid arrows, then its proposition is equivalent to
\[ \exists y_0,\ldots y_n: \; B_0\land \ldots \land B_l. \]
\end{itemize}

We note the following rules for manipulating \emph{true} diagrams:
\begin{itemize}
\item If we have two diagrams such that we can match the dashed arrows of one to the solid arrows of the other (such that the dashed arrow types imply the solid arrow types), then we can simply add the dashed lines of the second diagram to the first.
\item We can always remove dashed arrows and add solid arrows.
\end{itemize}

\begin{example}
Let $\sSet{X,R}$ be a rewriting system and $a,b\in X$.
\begin{itemize}
\item The joinability of $a$ and $b$ (i.e.\ $a\joins b$) is expressed by
\[ \begin{tikzcd}
a \arrow[r, dashed, "{*}"] & {} & b \arrow[l, dashed, swap, "{*}"]
\end{tikzcd}. \]
\item The Church-Rosser property is expressed by the diagram
\[ \begin{tikzcd}
x \arrow[rr, leftrightarrow, "{*}"] \arrow[dr, swap, dashed, "{*}"] & {} & y \arrow[dl, dashed, "{*}"] \\
{} & {} & {}
\end{tikzcd} \]
\item Confluence is expressed by the diagram
\[ \begin{tikzcd}
x \arrow[r, "{*}"] \arrow[d, swap, "{*}"] & y_1 \arrow[d, dashed, "{*}"] \\
y_2 \arrow[r, dashed, swap, "{*}"] & {}
\end{tikzcd} \]
\item Semi-confluence is expressed by the diagram
\[ \begin{tikzcd}
x \arrow[r] \arrow[d, swap, "{*}"] & y_1 \arrow[d, dashed, "{*}"] \\
y_2 \arrow[r, dashed, swap, "{*}"] & {}
\end{tikzcd} \]
\end{itemize}
\end{example}

\begin{proposition}[Induction on RS-diagrams] \label{inductionRSdiagrams}
Let $\sSet{X,R}$ be a rewriting system and $D_1, D_2$ two RS-diagrams such that $D_1$ implies $D_2$ and $D_1$ is a subdiagram of $D_1$.

If $D_1$ holds, then any diagram that we can obtain from $D_1$ by substituting in $D_2$ also holds.
\end{proposition}

\begin{lemma}
Let $\sSet{X,R}$ be a rewriting system. Then the diagram
\[ \begin{tikzcd}
{} & \arrow[dl, dashed, swap, "{?}"] z \arrow[dr, dashed, "{?}"] & {} \\
x \arrow[rr, leftrightarrow] & {} & y
\end{tikzcd} \qquad\text{holds.} \]
\end{lemma}
\begin{proof}
If $xRy$, then we may set $z = x$. If $yRx$, then we may set $z = y$.
\end{proof}

\begin{lemma}
Let $\sSet{X,R}$ be a rewriting system. Then the diagram
\[ \begin{tikzcd}
{} & z \arrow[dr] & {} \\
x \arrow[ur, "{*}"] \arrow[rr, dashed, "{*}"] & {} & z
\end{tikzcd} \qquad\text{holds.} \]
\end{lemma}
\begin{proof}
We have $R^*;R \subseteq R^*$.
\end{proof}

\begin{lemma}
Let $\sSet{X,R}$ be a semi-confluent rewriting system. Then any diagram of the form
\[ \begin{tikzcd}[column sep=1.8em]
{} & x_1 \arrow[dl] \arrow[dr] & {} & \arrow[dl]\arrow[dr] \hdots & {} & x_n \arrow[dl] \arrow[dr] & {} \\
y_0 \arrow[dr, dashed, "{*}"] & {} & \arrow[dl, swap, dashed, "{*}"] y_1 & \hdots & \arrow[ddll, swap, dashed, "{*}"] y_n  & {} & \arrow[dddlll, swap, dashed, "{*}"] y_{n+1} \\
{} & {} \arrow[dr, dashed, "{*}"] & {} &  {}  & {} &  {} & {} \\
{} & {} & {} \arrow[dr, dashed, "{*}"] & {} & {} & {} & {} \\
{} & {} & {} & {} & {} & {} & {} \\
\end{tikzcd} \qquad \text{holds.} \]
\end{lemma}
\begin{proof}
We prove this by induction \ref{inductionRSdiagrams} because we have the implications

\begin{align*}
\begin{tikzcd}[column sep=1.5em, row sep=1.5em, ampersand replacement=\&]
{} \& \arrow[dl] x_1 \arrow[dr] \& {} \\
y_0 \arrow[dr, dashed, "{*}"] \& {} \& \arrow[dl, dashed, swap, "{*}"] y_1 \\
{} \& {} \& {}
\end{tikzcd} \qquad&\implies\qquad \begin{tikzcd}[column sep=1.5em, row sep=1.5em, ampersand replacement=\&]
{} \& \arrow[dl] x_1 \arrow[dr] \& {} \& \arrow[dl] x_2 \arrow[dr] \& {} \\
y_0 \arrow[dr, dashed, "{*}"] \& {} \& \arrow[dl, dashed, swap, "{*}"] y_1 \& {} \& y_2 \\
{} \& {} \& {}
\end{tikzcd} \\
&\implies\qquad \begin{tikzcd}[column sep=1.5em, row sep=1.5em, ampersand replacement=\&]
{} \& \arrow[dl] x_1 \arrow[dr] \& {} \& \arrow[dl] x_2 \arrow[dr] \arrow[ddll, dashed, bend left, "{*}"] \& {} \\
y_0 \arrow[dr, dashed, "{*}"] \& {} \& \arrow[dl, dashed, swap, "{*}"] y_1 \& {} \& y_2 \\
{} \& {} \& {}
\end{tikzcd} \\
&\implies\qquad \begin{tikzcd}[column sep=1.5em, row sep=1.5em, ampersand replacement=\&]
{} \& \arrow[dl] x_1 \arrow[dr] \& {} \& \arrow[dl] x_2 \arrow[dr] \& {} \\
y_0 \arrow[dr, dashed, "{*}"] \& {} \& \arrow[dl, dashed, swap, "{*}"] y_1 \& {} \& y_2 \arrow[ddll, dashed, swap, "{*}"] \\
{} \& {} \arrow[dr, dashed, "{*}"] \& {} \\
{} \& {} \& {}
\end{tikzcd}
\end{align*}

. The base case
\[ \begin{tikzcd}[column sep=1.5em, row sep=1.5em]
{} & \arrow[dl] x_1 \arrow[dr] & {} \\
y_0 \arrow[dr, dashed, "{*}"] & {} & \arrow[dl, dashed, swap, "{*}"] y_1 \\
{} & {} & {}
\end{tikzcd} \qquad\text{is just confluence.} \]
For the induction step, we can fill in the extra nodes top to bottom such that the dashed lines hold, by confluence.
\end{proof}

\begin{lemma}
Let $\sSet{X,R}$ be a confluent rewriting system and $\seq{x_0,\ldots, x_n}$ a finite sequence on $X$.
\end{lemma}

\begin{proposition}
Let $\sSet{X, R}$ be a rewriting system. The following are equivalent:
\begin{enumerate}
\item $R$ has the Church-Rosser property;
\item $R$ is confluent;
\item $R$ is semi-confluent.
\end{enumerate}
\end{proposition}
\begin{proof}
$(1) \Rightarrow (2)$ Take $x,y_1, y_2\in X$ and assume $\big(x\mathrel{R^*}y_1\big) \land \big(x\mathrel{R^*}y_2\big)$. Then $y_1 \equiv_R y_2$ and so $y_1\joins y_2$ by the Church-Rosser property.


$(2) \Rightarrow (3)$ Immediate.

$(3) \Rightarrow (1)$
\end{proof}

\section{Term rewriting}
\begin{definition}
A \udef{string rewriting system} or \udef{semi-Thue system} is a pair $\sSet{\Sigma, R}$ where
\begin{itemize}
\item $\Sigma$ is a set (the \udef{alphabet});
\item $R$ is a binary relation on $\Sigma^*$. The elements of $R$ are called \udef{(rewriting) rules}.
\end{itemize}
\end{definition}

\chapter{Languages}
\begin{definition}
A \udef{language} is a set of strings.
\end{definition}

\begin{definition}
Let $L$ be a language in an alphabet $A$. Then we define the \udef{Kleene closure} of the language $L$ as
\[ L^* \defeq \Closure_\concat(L) \cup \{\seq{}\}. \]
\end{definition}
Note that $A^* = \setbuilder{\seq{a}}{a\in A}^*$.

\section{Grammars}
\begin{definition}
A \udef{(formal) grammar} is a tuple $G = \sSet{\Sigma, N, R, S}$ where
\begin{itemize}
\item $\Sigma$ is a finite set, called the \udef{alphabet} or set of \udef{terminal symbols};
\item $N$ a finite set, disjoint from $\Sigma$, of \udef{nonterminal symbols};
\item $R$ is relation on $(\Sigma \uplus V)^*$ that is a finite set; it is also called the set of \udef{production rules};
\item $S\in N$.
\end{itemize}
\end{definition}

\subsection{Chomsky hierarchy}
\subsubsection{Regular}
\subsubsection{Context-free}
\subsubsection{Context-sensitive}
\subsubsection{Recursively enumerable}


\section{Automata}
\begin{definition}
An \udef{automaton} is a $5$-tuple $M = \sSet{\Sigma, Q, \delta, q_0, F}$, where
\begin{itemize}
\item $\Sigma$ is a finite set, called the \udef{input alphabet} of the automaton,
\item $Q$ is a set of \udef{states},
\item $\delta: Q\times \Sigma\to Q$ is a function, called the \udef{transition function},
\item $q\in Q$ is the \udef{start state}, and
\item $F\subseteq Q$ is the set of \udef{accept states} or \udef{final states}.
\end{itemize}
We call the automaton \udef{finite} if $Q$ is finite.

The automaton $M$ defines a function $e_M: \Sigma^* \to Q^*$ recursively by
\[ \begin{cases}
e_M(\seq{}) = \seq{q_0}, \\
e_M(u\concat \seq{x}) = e_M(u)\concat \delta(e(u)_{-1}, x) & (u\in \Sigma^*, x\in \Sigma).
\end{cases} \]

We say $M$ \udef{accepts} a string $u\in \Sigma^*$ if $e_M(u)_{-1} \in F$.

The set of all strings in $\Sigma^*$ that are accepted by the automaton is the language \udef{recognised} by $M$, or just the \udef{language of $M$}:
\[ L_M \defeq \setbuilder{u\in\Sigma^*}{e_M(u)_{-1} \in F}. \]
\end{definition}

\begin{lemma} \label{automatonExecutionLength}
Let $M = \sSet{\Sigma, Q, \delta, q_0, F}$ be an automaton and $u\in \Sigma^*$. Then $\len(e_M(u)) = \len(u)+1$.
\end{lemma}

\begin{proposition}
Let $M_1 = \sSet{\Sigma, Q_1, \delta_1, q_{0,1}, F_1}$ and $M_2 = \sSet{\Sigma, Q_2, \delta_2, q_{0,2}, F_2}$ be automata that accept the languages $L_{M_1}$ and $L_{M_2}$ in the same alphabet $\Sigma$. Define
\[ \delta = \curry_2^{-1}\Big(a\mapsto (\delta_1(-, a), \delta_2(-, a))\Big). \]
Then
\begin{enumerate}
\item $M_{\cup} = \sSet{\Sigma, Q_1\times Q_2, \delta, (q_{0,1}, q_{0,2}), (F_1\times Q_1) \cup (F_2\times Q_2)}$ is an automaton that recognises $L_{M_1}\cup L_{M_2}$;
\item $M_{\cap} = \sSet{\Sigma, Q_1\times Q_2, \delta, (q_{0,1}, q_{0,2}), F_1 \times F_2}$ is an automaton that recognises $L_{M_1}\cap L_{M_2}$.
\end{enumerate}
\end{proposition}

\subsection{State diagrams}
TODO. Double circle for accept states.

\subsection{Constructions}
\subsubsection{Changing initial state}
\begin{definition}
Let $M = \sSet{\Sigma, Q, \delta, q_{0}, F}$ be an automaton and $q\in Q$. Then $M|_{q}$ is the automaton $\sSet{\Sigma, Q, \delta, q, F}$, i.e.\ the same automaton except the initial state has been replaced by $q$.
\end{definition}

\begin{lemma} \label{automatonRunFactorisation}
Let $M = \sSet{\Sigma, Q, \delta, q_{0}, F}$ be an automaton and $x,y\in \Sigma^*$. Then
\[ e_M(x \concat y) = e_M(x)\concat \big(e_{M|_{q_x}}(y)[1:]\big), \]
where $q_x = e_M(x)_{-1}$.
\end{lemma}
\begin{proof}
Consider the functions $y\mapsto e_M(x \concat y)$ and $y\mapsto e_M(x)\concat e_{M|_{q_x}}(y)$. They satisfy the same recursion relation and thus are the same by \ref{stringRecursion}.
\end{proof}

\subsection{Non-deterministic automata}
\begin{definition}
A \udef{non-deterministic automaton} is a $5$-tuple $M = \sSet{\Sigma, Q, \delta, Q_0, F}$, where
\begin{itemize}
\item $\Sigma$ is a finite set of symbols, called the \udef{input alphabet} of the automaton,
\item $Q$ is a set of \udef{states},
\item $\delta: Q\times \Sigma \to \powerset(Q)$ is a function, called the \udef{transition function},
\item $Q_0\subseteq Q$ is the \udef{start state}, and
\item $F\subseteq Q$ is the set of \udef{accept states} or \udef{final states}.
\end{itemize}
We call the non-deterministic automaton \udef{finite} if $Q$ is finite.

The automaton $M$ defines a function $e_M: \Sigma^* \to \powerset(Q^*)$ recursively by
\[ \begin{cases}
e(\seq{}) = \setbuilder{\seq{q_0}}{q_0\in Q_0}, \\
e(u\concat \seq{x}) = \setbuilder{v\concat q}{v\in e(u), q\in \delta(v_{-1}, x)} & (u\in \Sigma^*, x\in \Sigma).
\end{cases} \]

We say $M$ \udef{accepts} a string $u\in \Sigma^*$ if $\exists r\in e_M(u): r_{-1} \in F$.

The set of all strings in $\Sigma^*$ that are accepted by the automaton is the language \udef{recognised} by $M$, or just the \udef{language of $M$}:
\[ L_M \defeq \setbuilder{u\in\Sigma^*}{\exists r\in e_M(u): r_{-1} \in F}. \]
\end{definition}

\begin{lemma} \label{automatonAsNDAutomaton}
Let $M = \sSet{\Sigma, Q, \delta, q_0, F}$ be an automaton. Consider the non-deterministic automaton $M' = \sSet{\Sigma, Q, \delta', Q_0', F}$, where
\begin{itemize}
\item $Q_0' = \{q_0\}$; and
\item $\delta' = \{\delta(-)\}$.
\end{itemize}
Then
\begin{enumerate}
\item $e_{M} = \{e_{M'}(-)\}$;
\item $M$ and $M'$ accept the same language.
\end{enumerate}
\end{lemma}
\begin{proof}
Point (2) follows straight from point (1) and point (1) is easy to prove by induction on input string length.
\end{proof}

\begin{proposition}
Let $M_1 = \sSet{\Sigma, Q_1, \delta_1, Q_{0,1}, F_1}$ and $M_2 = \sSet{\Sigma, Q_2, \delta_2, Q_{0,2}, F_2}$ be non-deterministic automata that accept the languages $L_{M_1}$ and $L_{M_2}$ in the same alphabet $\Sigma$.
Then
\begin{enumerate}
\item $M_{\cup} = \sSet{\Sigma, Q_1\sqcup Q_2, (\delta_1 \bbslash \delta_2), Q_{0,1}\sqcup Q_{0,2}, F_1 \sqcup F_2}$ is a non-deterministic automaton that recognises $L_{M_1}\cup L_{M_2}$;
\item $M_\star = \sSet{\Sigma, (Q_1\setminus F_1) \sqcup (F_1\times Q_{0,2}) \sqcup (Q_2\setminus Q_{0,2}), \delta', Q_{0,1}, F_2}$, where
\[ \delta': (q,s)\mapsto \begin{cases}
\big(\delta_1(q,s)\setminus F_1\big) \sqcup \Big(\big(\delta_1(q,s)\cap F_1\big)\times Q_{0,2}\Big) & (q\in Q_1\setminus F_1) \\
\big(\delta_1(\proj_1(q),s)\setminus F_1\big) \sqcup \Big(\big(\delta_1(\proj_1(q),s)\cap F_1\big)\times Q_{0,2}\Big) \sqcup \delta_2\big(\proj_2(q), s\big) & (q\in F_1\times Q_{0,2}) \\
\delta_2(q,s) & (q\in Q_2\setminus Q_{0,2})
\end{cases} \]
is a non-deterministic automaton that recognises $L_{M_1}\concat L_{M_2}$.
\end{enumerate}
\end{proposition}

TODO: define (better syntax!!!!!!) + picture gluing of automata.

\begin{proposition}
Let $M = \sSet{\Sigma, Q, \delta, Q_{0}, F}$ be a non-deterministic automata that accept the languages $L_{M}$.
Then consider the non-deterministic automaton $M' = \sSet{\Sigma, Q', \delta', Q_{0}, F'}$, where
\begin{itemize}
\item $Q' = Q_0 \sqcup (Q\setminus F) \sqcup (F\times Q_0)$;
\item $\delta': (q,s) \mapsto \begin{cases}
\big(\delta(q,s)\setminus F\big) \sqcup \Big(\big(\delta(q,s)\cap F\big) \times Q_0\Big) & (\text{$q\in Q_0$ or $q\in Q\setminus F$}) \\
\begin{multlined}\big(\delta(\proj_1(q),s)\setminus F\big) \sqcup \Big(\big(\delta(\proj_1(q),s)\cap F\big) \times Q_0\Big) \vspace{-1em} \\ \cup \big(\delta(\proj_2(q),s)\setminus F\big) \sqcup \Big(\big(\delta(\proj_2(q),s)\cap F\big) \times Q_0\Big) \end{multlined}& (q\in F\times Q_0);
\end{cases}$
\item $F' = Q_0 \sqcup (F\times Q_0)$.
\end{itemize}
Then $M'$ recognises $L_{M}^*$.
\end{proposition}
Note the use of $\cup$ vs $\sqcup$.



\subsection{Finite automata}
\begin{definition}
A language is called a \udef{regular language} if it is recognised by a finite automaton.
\end{definition}

\begin{proposition}
Let $L$ be a language in an alphabet $\Sigma$. Then $L$ is recognised by a finite automaton \textup{if and only if} it is recognised by a finite non-deterministic automaton.
\end{proposition}
\begin{proof}
The direction $\Rightarrow$ is immediate from \ref{automatonAsNDAutomaton}.

For the converse, take a finite non-deterministic automaton $M = \sSet{\Sigma, Q, \delta, Q_0, F}$. Consider the automaton $M' = \sSet{\Sigma, \powerset{Q}, \delta', Q_0, F'}$, where
\begin{itemize}
\item $\delta': \powerset{Q} \times \Sigma \to \powerset{Q}: (A,s) \mapsto \bigcup_{q\in A}\delta(q, s)$;
\item $F' = \setbuilder{A\in \powerset(Q)}{A\mesh F}$.
\end{itemize}
Then we need to prove $L_{M} = L_{M'}$. Indeed we can prove by induction that, for all $u\in \Sigma^*$,
\[ \setbuilder{q_{-1}}{q\in e_M(u)} = e_{M'}(u)_{-1}. \]
Call this set $A$. We have that $M$ accepts $u$ iff $F\mesh A$ and $M'$ accepts $u$ iff $A\in F'$. By definition of $F'$, these cases are the same.
\end{proof}


\subsubsection{The pumping lemma}
\begin{theorem}[Pumping lemma]
Let $L$ be a regular language. Then there exists $p\in \N$ such that for all $s \in L$, we can write $s = x\concat y \concat z$ with
\begin{enumerate}
\item $x\concat y^k \concat z \in L$ for all $k\in\N$;
\item $\len(y) \geq 1$;
\item $\len(x\concat y) \leq p$.
\end{enumerate}
\end{theorem}
We also allow $k=0$, so $x\concat z$ must be an element of $L$.
\begin{proof}
Let $M = \sSet{\Sigma, Q, \delta, q_0, F}$ be a finite automaton that recognises $L$. Set $p = \#Q$. If $\len(s) \leq p$, then we can set $x=\seq{}, y= s$ and $z=\seq{}$.

Now assume $\len(s) > p$ and consider $e_M(s)$, which is a string in $Q$. By \ref{automatonExecutionLength}, we have
\[ \len(e_M(s)) = \len(s)+1 > p +1 = \#Q+1. \]
By \ref{stringPigeonholePrinciple} there must be a state in $e_M(s)[0:\#Q+1]$ that repeates. Let $k_1, k_2$ be the two different indices of this state in $e_M(s)$.

Then we may set $x = s[0:k_1]$, $y = s[k_1:k_2]$ and $z = s[k_2:]$.

Point (3) is satisfied as $\len(x\concat y) = k_2 \leq \#Q = p$.

Point (2) is satisfied as $k_1\neq k_2$.

For point (1), define the automaton $M' = \sSet{\Sigma, Q, \delta, e_M(x)_{-1}, F}$ and $M^{\prime\prime} = \sSet{\Sigma, Q, \delta, e_M(x\concat y)_{-1}, F}$.
It is enough to prove that
\[ e_M(x\concat y^k \concat z) = e_M(x)\concat \big(e_{M'}(y)[1:]\big)^k \concat \big(e_{M^{\prime\prime}}(z)[1:]\big). \]
We use \ref{automatonRunFactorisation}. We then only need to prove that $\big(e_{M'}(y^k)[1:]\big) = \big(e_{M'}(y)[1:]\big)^k$. This is evident by induction on $k$, using \ref{automatonRunFactorisation}.
\end{proof}

\begin{example}
The following languages are not regular:
\begin{itemize}
\item $\setbuilder{\seq{0}^n\seq{1}^n}{n\geq 0}$;
\item $\setbuilder{u\in \{0, 1\}^*}{\text{$u$ contains an equal number of $1$s and $0$s}}$;
\item $\setbuilder{u\concat u}{u\in \{0,1\}^*}$;
\item $\setbuilder{\seq{1}^{n^2}}{n\in \N}$;
\item $\setbuilder{\seq{0}^i\seq{1}^j}{i>j \in \N}$. We prove this by contradiction. Assume $p$ is the pumping length and consider $\seq{0}^{p+1}\seq{1}^p$, which is a string in the language. Then $y$ must consist of a non-empty string of zeros. Now the string $xy^0z = xz$ must be in the language by the pumping lemma. However in this case $xz = \seq{0}^l\seq{1}^j$ where $l\leq j$, which means that $xz$ is not an element of the language. This is a contradiction.
\end{itemize}
\end{example}