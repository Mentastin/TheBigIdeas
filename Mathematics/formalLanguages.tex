\chapter{Abstract rewriting systems}
\section{Definitions}
\begin{definition}
An \udef{(abstract) rewriting system} is a pair $\sSet{X, R}$ where
\begin{itemize}
\item $X$ is a set;
\item $R$ is a binary relation on $X$. The elements of $R$ are called \udef{(rewriting) rules}.
\end{itemize}
Let $x,y\in X$. Then we call
\begin{itemize}
\item $y$ a \udef{successor} of $x$ if $xR^+y$;
\item $y$ a \udef{direct successor} of $x$ if $xRy$.
\end{itemize}
We say
\begin{itemize}
\item $x$ is \udef{reducible} if there exists $y$ such that $x\mathrel{R}y$;
\item $x$ is \udef{irreducible} or \udef{in normal form} if $x$ is not reducible;
\item $y$ is a \udef{normal form of} $x$ if $xR^*y$ and $y$ is in normal form.
\end{itemize}
We say
\begin{itemize}
\item $x$ and $y$ are \udef{joinable} if $x\big(R^*;(R^\transp)^*\big)y$. We write $x \joins y$.
\end{itemize}
\end{definition}

\subsection{Properties of rewriting systems}
\begin{definition}
Let $\sSet{X, R}$ be a rewriting system. This system is called
\begin{itemize}
\item \udef{terminating} if $R^+$ is antisymmetric and satisfies the ascending chain condition;
\item \udef{normalising} if every element has a normal form;
\end{itemize}
it is said to
\begin{itemize}
\item have the \udef{Church-Rosser} property if $\forall x,y\in X: \; x\mathrel{\equiv_R}y \implies x \joins y$;
\item be \udef{confluent} if $\forall x,y_1, y_2\in X: \; \big(x\mathrel{R^*}y_1\big) \land \big(x\mathrel{R^*}y_2\big) \implies y_1 \joins y_2$;
\item be \udef{semi-confluent} if $\forall x,y_1, y_2\in X: \; \big(x\mathrel{R}y_1\big) \land \big(x\mathrel{R^*}y_2\big) \implies y_1 \joins y_2$.
\end{itemize}
The system is called
\begin{itemize}
\item \udef{convergent} if it is both confluent and terminating.
\end{itemize}
\end{definition}
Note that the Church-Rosser property is equivalent to
\[ \forall x,y\in X: \; x\mathrel{\equiv_R}y \iff x \joins y. \]

\begin{lemma}
Any terminating relation is normalising, but the converse is not true.
\end{lemma}
\begin{proof}

\end{proof}

\begin{lemma}

\end{lemma}
By \ref{welfoundedACC}, we have that 

\chapter{Strings and term rewriting}
\section{Strings}
\begin{definition}
A \udef{string} in an \udef{alphabet} $A$ is a sequence whose domain is a set of the form $\interval[co]{0,n}$ and whose codomain is the set $A$. The elements of $A$ are called \udef{symbols}.

The size $n$ of the domain is the \udef{length} of the sequence, denoted $\len(x)$. Thus $x: \interval[co]{0,\len(x)}\to A$.


We identify $n$ with the corresponding von Neumann ordinal to get
\begin{align*}
A^{n} &\defeq A^{\interval[co]{0,n}} \\
A^* &\defeq \bigcup\setbuilder{ A^{n}}{n\in \N}.
\end{align*}
We call $A^*$ the \udef{Kleene closure} of $A$.

Let $a_0,\ldots, a_{n-1}\in A$. Then we have the string
\[ \seq{a_0,\ldots, a_{n-1}} \defeq \{(0,a_0),\ldots, (n-1,a_{n-1})\} \in A^{n}. \]

Let $u\in A^*$ be a string. We take all indices modulo $\len(x)$. In particular negative indices can be used to count back from the end of the string.

\begin{itemize}
\item We allow the domain of a string to be $\emptyset = \interval[co]{0,0}$. There is a unique string with this domain, the \udef{empty string} $\seq{}$. We have $\seq{}\in A^*$.
\item Let $u\in A^{n}, v\in A^{m}$ be strings. The \udef{concatenation} of $u$ and $v$ is the string
\[ u\star v \defeq \seq{u_0,\ldots, u_{n-1},v_0,\ldots, v_{m-1}} \in A^{n+m}. \]
\item Let $u\in A^{n}$ be a string. The \udef{reverse} string $\reverse{u}$ is defined by
\[ \reverse{u} \defeq \seq{u_{n-1}, \ldots, u_0}. \]
\end{itemize}
We call a subsequence a \udef{substring} if its domain is an interval subset.
\end{definition}
Notice that we can view tuples as strings of length two (i.e.\ there is a bijection $A\times A \leftrightarrow A^{2}$ for all sets $A$). Similarly an $n$-tuple can be seen as a string of length $n$. So sometimes we write
\[ A^* = \bigcup^\infty_{n=0}A^n = A^{<\omega}\]
where $A^{<\omega}$ is just a notational equivalent.

We can think of $A^*$ as a generalisation of $\N$, with $\seq{}$ instead of $0$ and appending operators
\[ S_a(u) = u\concat \seq{a} \]
for all $a\in A$. In this way $\N \cong \{1\}^*$.


\begin{lemma} \label{stringPigeonholePrinciple}
Let $A$ be a finite alphabet and $u\in A^*$. If $\#A < \len(u)$, then $u$ has a repeating character.
\end{lemma}
\begin{proof}
Assume $\#A < \len(u)$. Then we have the inclusion $\interval[co]{0,\#A} \hookrightarrow \interval[co]{0,\len(u)}$ by \ref{naturalNumbersInequalityInclusion}. Also $A =_c \interval[co]{0,\#A}$ by definition.


We need to show that $u$ is not an injection. Assume, towards a contradiction, that it is injective. 
Then $\begin{tikzcd}
A \ar[r, "{=_c}"] &\interval[co]{0,\#A} \ar[r,hook] & \interval[co]{0,\len(u)} \ar[r, "u"] & A
\end{tikzcd}$
is injective. By the pigeonhole principle \ref{pigeonholePrinciple}, this map is bijective. Thus $u$ is surjective, so $\interval[co]{0,\len(u)} =_c A$, which means that $\len(u) = \#A$ by the unicity in \ref{finiteSetNumberOfElements}. This is a contradiction.
\end{proof}

\begin{theorem}[String recursion theorem] \label{stringRecursion}
Let $A,E$ be sets, $a\in E$, and $h:E\times A\to E$ some function.

There is exactly one function $f: A^*\to E$ which satisfies
\[ \begin{cases}
f(\seq{}) = a, \\
f(u\concat \seq{x}) = h(f(u), x) & (u\in A^*, x\in A).
\end{cases} \]
\end{theorem}
\begin{proof}
Define a function $\phi: \N \times A^*\to E$ recursively such that it satisfies
\begin{align*}
\phi(0,u) &= a \\
\phi(n+1,u) &= h(\phi(n,u), u(n))
\end{align*}
and set $f(u) = \phi(\len(u), u)$. Proving that $f$ satisfies the second equality and the uniqueness of $f$ goes by induction on $\len(u)$.
\end{proof}
Like before, a version of the theorem can also be stated for recursion with parameters.

\subsection{Ordering string}
\begin{definition}
Let $\sSet{A,\leq}$ be a linearly ordered alphabet. Then
\begin{itemize}
\item the \udef{lexicographic order} $<_l$ on $A^*$ is defined by
\[ u <_l v \qquad\iff\qquad u_k < v_k \;\text{where $k = \min\setbuilder{n\in\N}{n \leq \len(u), n\leq \len(v), u_n \neq v_n}$}. \]
\item the \udef{shortlex order} or \udef{strong order} $<_{s}$ on $A^*$ is defined by
\[ u <_l v \qquad\iff\qquad \begin{cases}
\len(u) < \len(v) & \text{or} \\
\big(\len(u) = \len(v)\big) \land (u <_l v).
\end{cases}\]
\end{itemize}
\end{definition}

\subsection{Slices and substrings}
\begin{definition}
Let $A$ be an alphabet, $u$ a string in $A$ and $S\subseteq \dom(u)$. Then the $S$-\udef{slice} of $u$ is the string
\[ u[S] \defeq \begin{tikzcd}
\interval[co]{0,\len(S)} \ar[r, "\cong"] & S \ar[r, "u|_S"] & A,
\end{tikzcd} \]
where $\interval[co]{0,\len(S)} \cong S$ is the unique order similarity of \ref{WOSetsUniqueSimilarity} (where $S$ has the subspace order).

We also allow $S$ to not be a subset of $\dom(u)$. In this case it is first replaced by $S\cap \dom(u)$.
\end{definition}

\section{Term rewriting}
\begin{definition}
A \udef{string rewriting system} or \udef{semi-Thue system} is a pair $\sSet{\Sigma, R}$ where
\begin{itemize}
\item $\Sigma$ is a set (the \udef{alphabet});
\item $R$ is a binary relation on $\Sigma^*$. The elements of $R$ are called \udef{(rewriting) rules}.
\end{itemize}
\end{definition}

\chapter{Languages}
\begin{definition}
A \udef{language} is a set of strings.
\end{definition}

\begin{definition}
Let $L$ be a language in an alphabet $A$. Then we define the \udef{Kleene closure} of the language $L$ as
\[ L^* \defeq \Closure_\concat(L) \cup \{\seq{}\}. \]
\end{definition}
Note that $A^* = \setbuilder{\seq{a}}{a\in A}^*$.

\section{Grammars}
\begin{definition}
A \udef{(formal) grammar} is a tuple $G = \sSet{\Sigma, N, R, S}$ where
\begin{itemize}
\item $\Sigma$ is a finite set, called the \udef{alphabet} or set of \udef{terminal symbols};
\item $N$ a finite set, disjoint from $\Sigma$, of \udef{nonterminal symbols};
\item $R$ is relation on $(\Sigma \uplus V)^*$ that is a finite set; it is also called the set of \udef{production rules};
\item $S\in N$.
\end{itemize}
\end{definition}

\subsection{Chomsky hierarchy}
\subsubsection{Regular}
\subsubsection{Context-free}
\subsubsection{Context-sensitive}
\subsubsection{Recursively enumerable}


\section{Automata}
\begin{definition}
An \udef{automaton} is a $5$-tuple $M = \sSet{\Sigma, Q, \delta, q_0, F}$, where
\begin{itemize}
\item $\Sigma$ is a finite set, called the \udef{input alphabet} of the automaton,
\item $Q$ is a set of \udef{states},
\item $\delta: Q\times \Sigma\to Q$ is a function, called the \udef{transition function},
\item $q\in Q$ is the \udef{start state}, and
\item $F\subseteq Q$ is the set of \udef{accept states} or \udef{final states}.
\end{itemize}
We call the automaton \udef{finite} if $Q$ is finite.

The automaton $M$ defines a function $e_M: \Sigma^* \to Q^*$ recursively by
\[ \begin{cases}
e_M(\seq{}) = \seq{q_0}, \\
e_M(u\concat \seq{x}) = e_M(u)\concat \delta(e(u)_{-1}, x) & (u\in \Sigma^*, x\in \Sigma).
\end{cases} \]

We say $M$ \udef{accepts} a string $u\in \Sigma^*$ if $e_M(u)_{-1} \in F$.

The set of all strings in $\Sigma^*$ that are accepted by the automaton is the language \udef{recognised} by $M$, or just the \udef{language of $M$}:
\[ L_M \defeq \setbuilder{u\in\Sigma^*}{e_M(u)_{-1} \in F}. \]
\end{definition}

\begin{lemma} \label{automatonExecutionLength}
Let $M = \sSet{\Sigma, Q, \delta, q_0, F}$ be an automaton and $u\in \Sigma^*$. Then $\len(e_M(u)) = \len(u)+1$.
\end{lemma}

\begin{proposition}
Let $M_1 = \sSet{\Sigma, Q_1, \delta_1, q_{0,1}, F_1}$ and $M_2 = \sSet{\Sigma, Q_2, \delta_2, q_{0,2}, F_2}$ be automata that accept the languages $L_{M_1}$ and $L_{M_2}$ in the same alphabet $\Sigma$. Define
\[ \delta = \curry_2^{-1}\Big(a\mapsto (\delta_1(-, a), \delta_2(-, a))\Big). \]
Then
\begin{enumerate}
\item $M_{\cup} = \sSet{\Sigma, Q_1\times Q_2, \delta, (q_{0,1}, q_{0,2}), (F_1\times Q_1) \cup (F_2\times Q_2)}$ is an automaton that recognises $L_{M_1}\cup L_{M_2}$;
\item $M_{\cap} = \sSet{\Sigma, Q_1\times Q_2, \delta, (q_{0,1}, q_{0,2}), F_1 \times F_2}$ is an automaton that recognises $L_{M_1}\cap L_{M_2}$.
\end{enumerate}
\end{proposition}

\subsection{State diagrams}
TODO. Double circle for accept states.

\subsection{Constructions}
\subsubsection{Changing initial state}
\begin{definition}
Let $M = \sSet{\Sigma, Q, \delta, q_{0}, F}$ be an automaton and $q\in Q$. Then $M|_{q}$ is the automaton $\sSet{\Sigma, Q, \delta, q, F}$, i.e.\ the same automaton except the initial state has been replaced by $q$.
\end{definition}

\begin{lemma} \label{automatonRunFactorisation}
Let $M = \sSet{\Sigma, Q, \delta, q_{0}, F}$ be an automaton and $x,y\in \Sigma^*$. Then
\[ e_M(x \concat y) = e_M(x)\concat \big(e_{M|_{q_x}}(y)[1:]\big), \]
where $q_x = e_M(x)_{-1}$.
\end{lemma}
\begin{proof}
Consider the functions $y\mapsto e_M(x \concat y)$ and $y\mapsto e_M(x)\concat e_{M|_{q_x}}(y)$. They satisfy the same recursion relation and thus are the same by \ref{stringRecursion}.
\end{proof}

\subsection{Non-deterministic automata}
\begin{definition}
A \udef{non-deterministic automaton} is a $5$-tuple $M = \sSet{\Sigma, Q, \delta, Q_0, F}$, where
\begin{itemize}
\item $\Sigma$ is a finite set of symbols, called the \udef{input alphabet} of the automaton,
\item $Q$ is a set of \udef{states},
\item $\delta: Q\times \Sigma \to \powerset(Q)$ is a function, called the \udef{transition function},
\item $Q_0\subseteq Q$ is the \udef{start state}, and
\item $F\subseteq Q$ is the set of \udef{accept states} or \udef{final states}.
\end{itemize}
We call the non-deterministic automaton \udef{finite} if $Q$ is finite.

The automaton $M$ defines a function $e_M: \Sigma^* \to \powerset(Q^*)$ recursively by
\[ \begin{cases}
e(\seq{}) = \setbuilder{\seq{q_0}}{q_0\in Q_0}, \\
e(u\concat \seq{x}) = \setbuilder{v\concat q}{v\in e(u), q\in \delta(v_{-1}, x)} & (u\in \Sigma^*, x\in \Sigma).
\end{cases} \]

We say $M$ \udef{accepts} a string $u\in \Sigma^*$ if $\exists r\in e_M(u): r_{-1} \in F$.

The set of all strings in $\Sigma^*$ that are accepted by the automaton is the language \udef{recognised} by $M$, or just the \udef{language of $M$}:
\[ L_M \defeq \setbuilder{u\in\Sigma^*}{\exists r\in e_M(u): r_{-1} \in F}. \]
\end{definition}

\begin{lemma} \label{automatonAsNDAutomaton}
Let $M = \sSet{\Sigma, Q, \delta, q_0, F}$ be an automaton. Consider the non-deterministic automaton $M' = \sSet{\Sigma, Q, \delta', Q_0', F}$, where
\begin{itemize}
\item $Q_0' = \{q_0\}$; and
\item $\delta' = \{\delta(-)\}$.
\end{itemize}
Then
\begin{enumerate}
\item $e_{M} = \{e_{M'}(-)\}$;
\item $M$ and $M'$ accept the same language.
\end{enumerate}
\end{lemma}
\begin{proof}
Point (2) follows straight from point (1) and point (1) is easy to prove by induction on input string length.
\end{proof}

\begin{proposition}
Let $M_1 = \sSet{\Sigma, Q_1, \delta_1, Q_{0,1}, F_1}$ and $M_2 = \sSet{\Sigma, Q_2, \delta_2, Q_{0,2}, F_2}$ be non-deterministic automata that accept the languages $L_{M_1}$ and $L_{M_2}$ in the same alphabet $\Sigma$.
Then
\begin{enumerate}
\item $M_{\cup} = \sSet{\Sigma, Q_1\sqcup Q_2, (\delta_1 \bbslash \delta_2), Q_{0,1}\sqcup Q_{0,2}, F_1 \sqcup F_2}$ is a non-deterministic automaton that recognises $L_{M_1}\cup L_{M_2}$;
\item $M_\star = \sSet{\Sigma, (Q_1\setminus F_1) \sqcup (F_1\times Q_{0,2}) \sqcup (Q_2\setminus Q_{0,2}), \delta', Q_{0,1}, F_2}$, where
\[ \delta': (q,s)\mapsto \begin{cases}
\big(\delta_1(q,s)\setminus F_1\big) \sqcup \Big(\big(\delta_1(q,s)\cap F_1\big)\times Q_{0,2}\Big) & (q\in Q_1\setminus F_1) \\
\big(\delta_1(\proj_1(q),s)\setminus F_1\big) \sqcup \Big(\big(\delta_1(\proj_1(q),s)\cap F_1\big)\times Q_{0,2}\Big) \sqcup \delta_2\big(\proj_2(q), s\big) & (q\in F_1\times Q_{0,2}) \\
\delta_2(q,s) & (q\in Q_2\setminus Q_{0,2})
\end{cases} \]
is a non-deterministic automaton that recognises $L_{M_1}\concat L_{M_2}$.
\end{enumerate}
\end{proposition}

TODO: define (better syntax!!!!!!) + picture gluing of automata.

\begin{proposition}
Let $M = \sSet{\Sigma, Q, \delta, Q_{0}, F}$ be a non-deterministic automata that accept the languages $L_{M}$.
Then consider the non-deterministic automaton $M' = \sSet{\Sigma, Q', \delta', Q_{0}, F'}$, where
\begin{itemize}
\item $Q' = Q_0 \sqcup (Q\setminus F) \sqcup (F\times Q_0)$;
\item $\delta': (q,s) \mapsto \begin{cases}
\big(\delta(q,s)\setminus F\big) \sqcup \Big(\big(\delta(q,s)\cap F\big) \times Q_0\Big) & (\text{$q\in Q_0$ or $q\in Q\setminus F$}) \\
\begin{multlined}\big(\delta(\proj_1(q),s)\setminus F\big) \sqcup \Big(\big(\delta(\proj_1(q),s)\cap F\big) \times Q_0\Big) \vspace{-1em} \\ \cup \big(\delta(\proj_2(q),s)\setminus F\big) \sqcup \Big(\big(\delta(\proj_2(q),s)\cap F\big) \times Q_0\Big) \end{multlined}& (q\in F\times Q_0);
\end{cases}$
\item $F' = Q_0 \sqcup (F\times Q_0)$.
\end{itemize}
Then $M'$ recognises $L_{M}^*$.
\end{proposition}
Note the use of $\cup$ vs $\sqcup$.



\subsection{Finite automata}
\begin{definition}
A language is called a \udef{regular language} if it is recognised by a finite automaton.
\end{definition}

\begin{proposition}
Let $L$ be a language in an alphabet $\Sigma$. Then $L$ is recognised by a finite automaton \textup{if and only if} it is recognised by a finite non-deterministic automaton.
\end{proposition}
\begin{proof}
The direction $\Rightarrow$ is immediate from \ref{automatonAsNDAutomaton}.

For the converse, take a finite non-deterministic automaton $M = \sSet{\Sigma, Q, \delta, Q_0, F}$. Consider the automaton $M' = \sSet{\Sigma, \powerset{Q}, \delta', Q_0, F'}$, where
\begin{itemize}
\item $\delta': \powerset{Q} \times \Sigma \to \powerset{Q}: (A,s) \mapsto \bigcup_{q\in A}\delta(q, s)$;
\item $F' = \setbuilder{A\in \powerset(Q)}{A\mesh F}$.
\end{itemize}
Then we need to prove $L_{M} = L_{M'}$. Indeed we can prove by induction that, for all $u\in \Sigma^*$,
\[ \setbuilder{q_{-1}}{q\in e_M(u)} = e_{M'}(u)_{-1}. \]
Call this set $A$. We have that $M$ accepts $u$ iff $F\mesh A$ and $M'$ accepts $u$ iff $A\in F'$. By definition of $F'$, these cases are the same.
\end{proof}


\subsubsection{The pumping lemma}
\begin{theorem}[Pumping lemma]
Let $L$ be a regular language. Then there exists $p\in \N$ such that for all $s \in L$, we can write $s = x\concat y \concat z$ with
\begin{enumerate}
\item $x\concat y^k \concat z \in L$ for all $k\in\N$;
\item $\len(y) \geq 1$;
\item $\len(x\concat y) \leq p$.
\end{enumerate}
\end{theorem}
We also allow $k=0$, so $x\concat z$ must be an element of $L$.
\begin{proof}
Let $M = \sSet{\Sigma, Q, \delta, q_0, F}$ be a finite automaton that recognises $L$. Set $p = \#Q$. If $\len(s) \leq p$, then we can set $x=\seq{}, y= s$ and $z=\seq{}$.

Now assume $\len(s) > p$ and consider $e_M(s)$, which is a string in $Q$. By \ref{automatonExecutionLength}, we have
\[ \len(e_M(s)) = \len(s)+1 > p +1 = \#Q+1. \]
By \ref{stringPigeonholePrinciple} there must be a state in $e_M(s)[0:\#Q+1]$ that repeates. Let $k_1, k_2$ be the two different indices of this state in $e_M(s)$.

Then we may set $x = s[0:k_1]$, $y = s[k_1:k_2]$ and $z = s[k_2:]$.

Point (3) is satisfied as $\len(x\concat y) = k_2 \leq \#Q = p$.

Point (2) is satisfied as $k_1\neq k_2$.

For point (1), define the automaton $M' = \sSet{\Sigma, Q, \delta, e_M(x)_{-1}, F}$ and $M^{\prime\prime} = \sSet{\Sigma, Q, \delta, e_M(x\concat y)_{-1}, F}$.
It is enough to prove that
\[ e_M(x\concat y^k \concat z) = e_M(x)\concat \big(e_{M'}(y)[1:]\big)^k \concat \big(e_{M^{\prime\prime}}(z)[1:]\big). \]
We use \ref{automatonRunFactorisation}. We then only need to prove that $\big(e_{M'}(y^k)[1:]\big) = \big(e_{M'}(y)[1:]\big)^k$. This is evident by induction on $k$, using \ref{automatonRunFactorisation}.
\end{proof}

\begin{example}
The following languages are not regular:
\begin{itemize}
\item $\setbuilder{\seq{0}^n\seq{1}^n}{n\geq 0}$;
\item $\setbuilder{u\in \{0, 1\}^*}{\text{$u$ contains an equal number of $1$s and $0$s}}$;
\item $\setbuilder{u\concat u}{u\in \{0,1\}^*}$;
\item $\setbuilder{\seq{1}^{n^2}}{n\in \N}$;
\item $\setbuilder{\seq{0}^i\seq{1}^j}{i>j \in \N}$. We prove this by contradiction. Assume $p$ is the pumping length and consider $\seq{0}^{p+1}\seq{1}^p$, which is a string in the language. Then $y$ must consist of a non-empty string of zeros. Now the string $xy^0z = xz$ must be in the language by the pumping lemma. However in this case $xz = \seq{0}^l\seq{1}^j$ where $l\leq j$, which means that $xz$ is not an element of the language. This is a contradiction.
\end{itemize}
\end{example}