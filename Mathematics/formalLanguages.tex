\chapter{Abstract rewriting systems}
\section{Definitions}
\begin{definition}
An \udef{(abstract) rewriting system} is a pair $\sSet{X, R}$ where
\begin{itemize}
\item $X$ is a set;
\item $R$ is a binary relation on $X$. The elements of $R$ are called \udef{(rewriting) rules}.
\end{itemize}
Let $x,y\in X$. Then we call
\begin{itemize}
\item $y$ a \udef{successor} of $x$ if $xR^+y$;
\item $y$ a \udef{direct successor} of $x$ if $xRy$.
\end{itemize}
We say
\begin{itemize}
\item $x$ is \udef{reducible} if there exists $y$ such that $x\mathrel{R}y$;
\item $x$ is \udef{irreducible} or \udef{in normal form} if $x$ is not reducible;
\item $y$ is a \udef{normal form of} $x$ if $xR^*y$ and $y$ is in normal form.
\end{itemize}
We say
\begin{itemize}
\item $x$ and $y$ are \udef{joinable} if $x\big(R^*;(R^\transp)^*\big)y$. We write $x \joins y$.
\end{itemize}
\end{definition}

\subsection{Properties of rewriting systems}
\begin{definition}
Let $\sSet{X, R}$ be a rewriting system. This system is called
\begin{itemize}
\item \udef{terminating} if $R^+$ is satisfies the ascending chain condition;
\item \udef{normalising} if every element has a normal form;
\end{itemize}
it is said to
\begin{itemize}
\item have the \udef{Church-Rosser} property if $\forall x,y\in X: \; x\mathrel{\equiv_R}y \implies x \joins y$;
\item be \udef{confluent} if $\forall x,y_1, y_2\in X: \; \big(x\mathrel{R^*}y_1\big) \land \big(x\mathrel{R^*}y_2\big) \implies y_1 \joins y_2$;
\item be \udef{semi-confluent} if $\forall x,y_1, y_2\in X: \; \big(x\mathrel{R}y_1\big) \land \big(x\mathrel{R^*}y_2\big) \implies y_1 \joins y_2$.
\end{itemize}
The system is called
\begin{itemize}
\item \udef{convergent} if it is both confluent and terminating.
\end{itemize}
\end{definition}
Note that the Church-Rosser property is equivalent to
\[ \forall x,y\in X: \; x\mathrel{\equiv_R}y \iff x \joins y. \]
In other words, two elements are equivalent if and only if they are joinable.

A rewriting system $\sSet{X, R}$ is normalising if and only if the associated tree $\sSet{T_R, \sqsubseteq}$ is coatomic. The normal forms are the coatoms.

\begin{lemma} \label{successionNormalForm}
Let $\sSet{X,R}$ be a rewriting system and $x\in X$ in normal form. If $y\in X$ is such that $xR^*y$, then $y=x$. 
\end{lemma}

\begin{proposition}
Any terminating relation is normalising, but the converse is not true.
\end{proposition}
This result assumes DC.
\begin{proof}
Let $\sSet{X, R}$ be a non-normalising rewriting system. Then we can find $u\in T_R$ such that $u{\sqsubseteq}$ does not contains a terminal node. Thus ${\sqsubseteq}u \cup u{\sqsubseteq}$ is a pruned tree. By \ref{ZornEquivalentsDC} it contains an infinite branch. Thus $T_R$ contains an infinite branch and $R$ is not terminating.

The following example shows that the converse is not true.
\end{proof}

\begin{example}
Confluent, normalising and asymmetric, but not terminating.
\[ \begin{tikzcd}
\bullet \rar \dar & \bullet \rar \ar[dl] & \bullet \rar \ar[dll] & \hdots \\
\bullet
\end{tikzcd} \]
\end{example}


\subsubsection{Diagrams for rewriting systems}
\begin{definition}
Let $\sSet{X,R}$ be a rewriting system. An \udef{RS-diagram} is a diagram with nodes and arrows between the nodes.
\begin{itemize}
\item Each node is labeled either by a variable (in which case we call it a variable node) or a constant (in which case we call it a constant node).
\item A constant node is drawn in a box.
\item An unlabeled node is implicitly a variable node.
\end{itemize}
Each arrow represents a proposition (with two unbounded variables):
\begin{itemize}
\item $x\to y$ represents $xRy$;
\item $x\leftrightarrow y$ represents $x(R\cup R^\transp)y$;
\item $x\overset{?}{\to}y$ represents $x(R\cup \id_X)y$;
\item $x\overset{+}{\to}y$ represents $xR^+y$;
\item $x\overset{*}{\to}y$ represents $xR^*y$;
\item $x\overset{n}{\to}y$ for some $n\in \N$ represents $xR^ny$;
\item $x\overset{-1}{\to}y$ represents $xR^\transp y$;
\item $x\overset{?}{\leftrightarrow}y$ represents $x(R\cup R^\transp \cup \id_X)y$;
\item $x\overset{+}{\leftrightarrow}y$ represents $x(R\cup R^\transp)^+y$;
\item $x\overset{*}{\leftrightarrow}y$ represents $x(R\cup R^\transp)^*y$;
\item $x\overset{n}{\leftrightarrow}y$ for some $n\in \N$ represents $x(R\cup R^\transp)^ny$.
\end{itemize}
Each arrow may be solid or dashed. Let
\begin{itemize}
\item $x_0, \ldots x_n$ be the variables that label variable nodes connected by at least one solid arrow;
\item $y_0,\ldots y_n$ the other variables in the diagram;
\item $A_0, \ldots, A_k$ the propositions represented by the solid arrows;
\item $B_0, \ldots, B_l$ the propositions represented by the dashed arrows.
\end{itemize}
Then the diagram represents the proposition
\[ \forall x_0, \ldots x_n \in X: \Big(A_0\land \ldots\land A_k \land\textbf{TRUE} \; \implies\; \exists y_0,\ldots y_n: (B_0\land \ldots \land B_l) \lor\textbf{FALSE} \Big). \]
\end{definition}

The addition of the constants TRUE and FALSE is for when a diagram contains either no solid or no dashed arrows.

\begin{itemize}
\item If the diagram contains no dashed arrows, then it is trivially true.
\item If the diagram contains no solid arrows, then its proposition is equivalent to
\[ \exists y_0,\ldots y_n: \; B_0\land \ldots \land B_l. \]
\end{itemize}

We note the following rules for manipulating \emph{true} diagrams:
\begin{itemize}
\item If we have two diagrams such that we can match the dashed arrows of one to the solid arrows of the other (such that the dashed arrow types imply the solid arrow types), then we can simply add the dashed lines of the second diagram to the first.
\item We can always remove dashed arrows and add solid arrows.
\end{itemize}

\begin{example}
Let $\sSet{X,R}$ be a rewriting system and $a,b\in X$.
\begin{itemize}
\item The joinability of $a$ and $b$ (i.e.\ $a\joins b$) is expressed by
\[ \begin{tikzcd}
a \arrow[r, dashed, "{*}"] & {} & b \arrow[l, dashed, swap, "{*}"]
\end{tikzcd}. \]
\item In any rewriting system, we have the diagram
\[ \begin{tikzcd}
x \arrow[rr, dashed, leftrightarrow, "{*}"] \arrow[dr, swap, "{*}"] & {} & y \arrow[dl, "{*}"] \\
{} & {} & {}
\end{tikzcd} \]
\item The Church-Rosser property is expressed by the diagram
\[ \begin{tikzcd}
x \arrow[rr, leftrightarrow, "{*}"] \arrow[dr, swap, dashed, "{*}"] & {} & y \arrow[dl, dashed, "{*}"] \\
{} & {} & {}
\end{tikzcd} \]
\item Confluence is expressed by the diagram
\[ \begin{tikzcd}
x \arrow[r, "{*}"] \arrow[d, swap, "{*}"] & y_1 \arrow[d, dashed, "{*}"] \\
y_2 \arrow[r, dashed, swap, "{*}"] & {}
\end{tikzcd} \]
\item Semi-confluence is expressed by the diagram
\[ \begin{tikzcd}
x \arrow[r] \arrow[d, swap, "{*}"] & y_1 \arrow[d, dashed, "{*}"] \\
y_2 \arrow[r, dashed, swap, "{*}"] & {}
\end{tikzcd} \]
\end{itemize}
\end{example}

\begin{proposition}[Induction on RS-diagrams] \label{inductionRSdiagrams}
Let $\sSet{X,R}$ be a rewriting system and $D_1, D_2$ two RS-diagrams such that $D_1$ implies $D_2$ and $D_1$ is a subdiagram of $D_2$.

If $D_1$ holds, then any diagram that we can obtain from $D_1$ by substituting in $D_2$ also holds.
\end{proposition}

TODO: general form of repeated application of a rule.

\begin{lemma} \label{triangelRSdiagrams}
Let $\sSet{X,R}$ be a rewriting system. Then the diagram
\[ \begin{tikzcd}
{} & \arrow[dl, dashed, swap, "{?}"] z \arrow[dr, dashed, "{?}"] & {} \\
x \arrow[rr, leftrightarrow] & {} & y
\end{tikzcd} \qquad\text{holds.} \]
\end{lemma}
\begin{proof}
If $xRy$, then we may set $z = x$. If $yRx$, then we may set $z = y$.
\end{proof}

\begin{lemma} \label{transitiveClosureRSdiagram}
Let $\sSet{X,R}$ be a rewriting system. Then the diagram
\[ \begin{tikzcd}
{} & z \arrow[dr] & {} \\
x \arrow[ur, "{*}"] \arrow[rr, dashed, "{*}"] & {} & y
\end{tikzcd} \qquad\text{holds.} \]
\end{lemma}
\begin{proof}
We have $R^*;R \subseteq R^*$.
\end{proof}


TODO
\[ \begin{tikzcd}
{} & \arrow[dl, swap, "{*}"] z \arrow[dr, "{*}"] & {} \\
x \arrow[rr, dashed, leftrightarrow, "{*}"] & {} & y
\end{tikzcd} \qquad\text{holds.} \]


\begin{lemma} \label{confluenceInduction}
Let $\sSet{X,R}$ be a confluent rewriting system. Then any diagram of the form
\[ \begin{tikzcd}[column sep=1.8em]
{} & x_1 \arrow[dl, swap, "{*}"] \arrow[dr, "{*}"] & {} & \arrow[dl, swap, "{*}"]\arrow[dr, "{*}"] \hdots & {} & x_n \arrow[dl, swap, "{*}"] \arrow[dr, "{*}"] & {} \\
y_0 \arrow[dr, dashed, "{*}"] & {} & \arrow[dl, swap, dashed, "{*}"] y_1 & \hdots & \arrow[ddll, swap, dashed, "{*}"] y_n  & {} & \arrow[dddlll, swap, dashed, "{*}"] y_{n+1} \\
{} & {} \arrow[dr, dashed, "{*}"] & {} &  {}  & {} &  {} & {} \\
{} & {} & {} \arrow[dr, dashed, "{*}"] & {} & {} & {} & {} \\
{} & {} & {} & {} & {} & {} & {} \\
\end{tikzcd} \qquad \text{holds.} \]
\end{lemma}
\begin{proof}
We prove this by induction \ref{inductionRSdiagrams} because we have the implications

\begin{align*}
\begin{tikzcd}[column sep=1.5em, row sep=1.5em, ampersand replacement=\&]
{} \& \arrow[dl, swap, "{*}"] x \arrow[dr, "{*}"] \& {} \\
y \arrow[dr, dashed, "{*}"] \& {} \& \arrow[dl, dashed, swap, "{*}"] y' \\
{} \& {} \& {}
\end{tikzcd} \qquad&\implies\qquad \begin{tikzcd}[column sep=1.5em, row sep=1.5em, ampersand replacement=\&]
{} \& \arrow[dl, swap, "{*}"] x \arrow[dr, "{*}"] \& {} \& \arrow[dl, swap, "{*}"] x' \arrow[dr, "{*}"] \& {} \\
y \arrow[dr, dashed, "{*}"] \& {} \& \arrow[dl, dashed, swap, "{*}"] y' \& {} \& y^{\prime\prime} \\
{} \& {} \& {}
\end{tikzcd} \\
&\implies\qquad \begin{tikzcd}[column sep=1.5em, row sep=1.5em, ampersand replacement=\&]
{} \& \arrow[dl, swap, "{*}"] x \arrow[dr, "{*}"] \& {} \& \arrow[dl, swap, "{*}"] x \arrow[dr, "{*}"] \arrow[ddll, dashed, bend left, "{*}"] \& {} \\
y \arrow[dr, dashed, "{*}"] \& {} \& \arrow[dl, dashed, swap, "{*}"] y' \& {} \& y^{\prime\prime} \\
{} \& {} \& {}
\end{tikzcd} \\
&\implies\qquad \begin{tikzcd}[column sep=1.5em, row sep=1.5em, ampersand replacement=\&]
{} \& \arrow[dl, swap, "{*}"] x \arrow[dr, "{*}"] \& {} \& \arrow[dl, swap, "{*}"] x' \arrow[dr, "{*}"] \& {} \\
y \arrow[dr, dashed, "{*}"] \& {} \& \arrow[dl, dashed, swap, "{*}"] y' \& {} \& y^{\prime\prime} \arrow[ddll, dashed, swap, "{*}"] \\
{} \& {} \arrow[dr, dashed, "{*}"] \& {} \\
{} \& {} \& {}
\end{tikzcd}
\end{align*}
The second implication uses \ref{transitiveClosureRSdiagram} and the third uses confluence. The base case is just confluence.
\end{proof}

\begin{proposition} \label{confluenceEquivalents}
Let $\sSet{X, R}$ be a rewriting system. The following are equivalent:
\begin{enumerate}
\item $R$ has the Church-Rosser property;
\item $R$ is confluent;
\item $R$ is semi-confluent.
\end{enumerate}
\end{proposition}
\begin{proof}
$(1) \Rightarrow (2)$ Take $x,y_1, y_2\in X$ and assume $\big(x\mathrel{R^*}y_1\big) \land \big(x\mathrel{R^*}y_2\big)$. Then $y_1 \equiv_R y_2$ and so $y_1\joins y_2$ by the Church-Rosser property.


$(2) \Rightarrow (1)$ Take $x,y\in X$ such that $x\equiv_R y$. Then there exists a finite sequence $\seq{x,x_0,\ldots, x_n, y}$ such that each pair of adjacent terms in the sequence is an element of $R\cup R^\transp$. I.e.\ we have
\[ \begin{tikzcd}
x \ar[r, leftrightarrow] & x_0 \ar[r, leftrightarrow] & \hdots \ar[r, leftrightarrow] & x_n \ar[r, leftrightarrow] & y
\end{tikzcd} \]
By \ref{triangelRSdiagrams}, this implies
\[ \begin{tikzcd}[column sep=1.5em, row sep=1.5em]
{}& \arrow[dl, dashed, swap, "{?}"]{}\arrow[dr, dashed, "{?}"] & &\arrow[dl, dashed, swap, "{?}"]{}\arrow[dr, dashed, "{?}"]&{}&\arrow[dl, dashed, swap, "{?}"]{}\arrow[dr, dashed, "{?}"]&{}&\arrow[dl, dashed, swap, "{?}"]{}\arrow[dr, dashed, "{?}"]&{} \\
x \ar[rr, leftrightarrow] &{}& x_0 \ar[rr, leftrightarrow] &{}& \hdots \ar[rr, leftrightarrow] &{}& x_n \ar[rr, leftrightarrow] &{}& y
\end{tikzcd} \]
By \ref{confluenceInduction}, this implies (as $\overset{?}{\to}$ implies $\overset{*}{\to}$)
\[ \begin{tikzcd}[column sep=1.5em, row sep=1.5em]
{}& \arrow[dl, dashed, swap, "{?}"]{}\arrow[dr, dashed, "{?}"] & &\arrow[dl, dashed, swap, "{?}"]{}\arrow[dr, dashed, "{?}"]&{}&\arrow[dl, dashed, swap, "{?}"]{}\arrow[dr, dashed, "{?}"]&{}&\arrow[dl, dashed, swap, "{?}"]{}\arrow[dr, dashed, "{?}"]&{} \\
x \ar[rr, leftrightarrow]\arrow[dr, dashed, "{*}"] \arrow[ddddrrrr, dashed, bend right, "{*}"] &{}& x_0 \ar[rr, leftrightarrow]\arrow[dl, swap, dashed, "{*}"] &{}& \arrow[ddll, swap, dashed, "{*}"] \hdots \ar[rr, leftrightarrow] &{}& x_n \arrow[dddlll, swap, dashed, "{*}"] \ar[rr, leftrightarrow] &{}& y \arrow[ddddllll, swap, dashed, "{*}"] \\
{}&{}\arrow[dr, dashed, "{*}"]&{}&{}&{}&{}&{}&{}&{} \\
{}&{}&{}\arrow[dr, dashed, "{*}"]&{}&{}&{}&{}&{}&{} \\
{}&{}&{}&{}\arrow[dr, dashed, "{*}"]&{}&{}&{}&{}&{} \\
{}&{}&{}&{}&{}&{}&{}&{}&{} \\
\end{tikzcd} \]
Removing extraneous arrows gives $\begin{tikzcd}
x \arrow[rr, leftrightarrow, "{*}"] \arrow[dr, dashed, "{*}"] &{}& y \arrow[dl, dashed, swap, "{*}"] \\
{} & {} & {}
\end{tikzcd}$, which is the Church-Rosser property.

$(2) \Rightarrow (3)$ Immediate.

$(3) \Rightarrow (1)$ Assume semi-confluence. We prove this by diagrammatic induction. We take two base cases:
\[ \begin{tikzcd}
{} & {} \arrow[dl, swap, "{*}"] \\
{} \arrow[dr, dashed, "{*}"] & {} \\
{}&{}
\end{tikzcd} \qquad\text{and}\qquad \begin{tikzcd}[column sep=1.5em, row sep=1.5em]
{} & {} \arrow[dl, swap, "{*}"] \arrow[dr] & {} \\
{} \arrow[dr, dashed, "{*}"] & {} & {} \arrow[dl, swap, dashed, "{*}"] \\
{}&{}&{} 
\end{tikzcd} \qquad \text{hold.} \]
Because of semi-confluence, we have the implication
\begin{align*}
\begin{tikzcd}[column sep=1.5em, row sep=1.5em, ampersand replacement=\&]
{} \& \arrow[dl, swap, "{*}"] {} \arrow[dr] \& {} \\
{} \arrow[dr, dashed, "{*}"] \& {} \& \arrow[dl, dashed, swap, "{*}"] {} \\
{} \& {} \& {}
\end{tikzcd} \qquad&\implies\qquad \begin{tikzcd}[column sep=1.5em, row sep=1.5em, ampersand replacement=\&]
{} \& \arrow[dl, swap, "{*}"] {} \arrow[dr] \& {} \& {} \\
{} \arrow[dr, dashed, "{*}"] \& {} \& \arrow[dl, dashed, swap, "{*}"] \arrow[dr] {} \& {} \\
{} \& {} \& {} \& {} \\
{} \& {} \& {} \& {}
\end{tikzcd} \\
\qquad&\implies\qquad \begin{tikzcd}[column sep=1.5em, row sep=1.5em, ampersand replacement=\&]
{} \& \arrow[dl, swap, "{*}"] {} \arrow[dr] \& {} \& {} \\
{} \arrow[dr, dashed, "{*}"] \& {} \& \arrow[dl, dashed, swap, "{*}"] \arrow[dr] {} \& {} \\
{} \& {} \arrow[dr, dashed, "{*}"] \& {} \& {} \arrow[dl, dashed, swap, "{*}"] \\
{} \& {} \& {} \& {}
\end{tikzcd}
\end{align*}
\end{proof}
\begin{corollary} \label{confluenceUniquenessNormalForm}
Let $\sSet{X,R}$ be a confluent rewriting system. Then
\begin{enumerate}
\item if $x\equiv_R y$ and $y$ is in normal form, then $xR^*y$;
\item if $x\equiv_R y$ and $x, y$ are both in normal form, then $x = y$;
\item every element has at most one normal form.
\end{enumerate}
\end{corollary}
\begin{proof}
(1) As $\sSet{X,R}$ is Church-Rosser, we have $\begin{tikzcd}[column sep=small, row sep=small]
\boxed{x} \arrow[rr, leftrightarrow, "{*}"] \arrow[dr, dashed, "{*}"] &{}& \boxed{y} \arrow[dl, dashed, swap, "{*}"] \\
{} & {z} & {}
\end{tikzcd}$. As $y$ is in normal form, we have $z = y$ (by \ref{successionNormalForm}). Thus $xR^*y$.

(2) By \ref{successionNormalForm}.

(3) Let $y_1, y_2$ both be normal forms of $x$. Then $y_1 (R^\transp)^* x R^* y_2$, so $y_1 \equiv_R y_2$ and $y_1 = y_2$ by (2).
\end{proof}

\begin{proposition}
Let $\sSet{X,R}$ be a rewriting system. Then the rewriting system is confluent and normalising \textup{if and only if} every element has a unique normal form.
\end{proposition}
\begin{proof}
$\boxed{\Rightarrow}$ Normalising implies existence (by definition) and confluence implies unicity by \ref{confluenceUniquenessNormalForm}.

$\boxed{\Leftarrow}$ The rewriting system is normalising by definition. For confluence, assume $x R^* y_1$ and $xR^*y_2$. Let $y_1',y_2'$ be the normal forms of $y_1$ and $y_2$, respectively.

Then $xR^*y_1 R^*y_1'$, so $xR^*y_1'$. Also $xR^*y_2'$. Thus both $y_1'$ and $y_2'$ are normal forms of $x$. By unicity $y_1' = y_2' = y'$, so $y_1 R^* y' (R^\transp)^* y_2$, which means that $y_1 \joins y_2$ and thus that the rewriting system is confluent.
\end{proof}

\begin{definition}
Let $\sSet{X,R}$ be a confluent and normalising rewriting system. The unique normal form of $x\in X$ is denoted $\normalform{x}$.
\end{definition}

\begin{proposition}
Let $\sSet{X,R}$ be a confluent and normalising rewriting system and $x,y\in X$. Then $x \equiv_R y$ \textup{if and only if} $\normalform{x} = \normalform{y}$.
\end{proposition}
\begin{proof}
$\boxed{\Rightarrow}$ From $x \equiv_R y$, we have $\normalform{x} \equiv_R \normalform{y}$ and thus $\normalform{x} = \normalform{y}$ by \ref{confluenceUniquenessNormalForm}.

$\boxed{\Leftarrow}$ Set $z = \normalform{x} = \normalform{y}$. Then $x R^* z (R^\transp)^* y$, so $x \equiv_R y$.
\end{proof}

\section{Termination}
\subsection{Progress functions}
\begin{proposition} \label{rewritingSystemProgressFunction}
Let $\sSet{X, R}$ be a rewriting system and $\sSet{Y,S}$ a terminating rewriting system.

If there exists a monotone function $f: X \to Y$, then $X$ is also terminating.
\end{proposition}
\begin{proof}
We have that $(\lambda_f)^\imf(T_R)$ is a subtree of $T_S$ by \ref{monotoneFunctionSubAssociatedTree}.

We prove the contrapositive: Assume $X$ is not terminating. Then we can find an infinite branch $S\in [T_R]$ and $(\lambda_f)^\imf(S)$ is an infinite branch in $(\lambda_f)^\imf(T_R) \subseteq T_S$, so $Y$ is not terminating.
\end{proof}

\begin{lemma}
A finitely branching rewriting system $\sSet{X,R}$ terminates \textup{if and only if} there exists a monotone function $f: \sSet{X,R} \to \sSet{\N,>}$.
\end{lemma}
\begin{proof}
$\boxed{\Rightarrow}$ Let $\sSet{X,R}$ be a finitely branching rewriting system. Take $x\in X$. Then $xR^+$ is finite by KÅ‘nig's lemma (TODO ref!). So we can define $\varphi: \sSet{X, R^+}\to \sSet{\N, >}: x\mapsto \#(xR^+)$. This is clearly monotone because $xR;R^+ \subseteq xR^+$.

$\boxed{\Leftarrow}$ Follows from \ref{rewritingSystemProgressFunction}.
\end{proof}

\section{Confluence}
TODO put Church-Rosser equivalence here? And combine definition of local confluence above?
\subsection{Confluence-related properties}
\begin{definition}
Let $\sSet{X,R}$ be a rewriting system. The system is said
\begin{itemize}
\item to be \udef{locally confluent} if 
$\forall x,y_1, y_2\in X: \; \big(x\mathrel{R}y_1\big) \land \big(x\mathrel{R}y_2\big) \implies y_1 \joins y_2$;
\item to be \udef{strongly confluent} if $\forall x,y_1, y_2\in X: \; \big(x\mathrel{R}y_1\big) \land \big(x\mathrel{R}y_2\big) \implies \exists z:  \big(y_1 \mathrel{R^*}x\big) \land \big(y_2\mathrel{R^?}x\big)$;
\item to have the \udef{diamond property} if $\forall x,y_1, y_2\in X: \; \big(x\mathrel{R}y_1\big) \land \big(x\mathrel{R}y_2\big) \implies \exists z: \big(y_1 \mathrel{R}x\big) \land \big(y_2\mathrel{R}x\big)$.
\end{itemize}
\end{definition}

\begin{example}
Let $\sSet{X,R}$ be a rewriting system.
\begin{itemize}
\item Local confluence is expressed by the diagram
\[ \begin{tikzcd}
x \arrow[r, "{}"] \arrow[d, swap, "{}"] & y_1 \arrow[d, dashed, "{*}"] \\
y_2 \arrow[r, dashed, swap, "{*}"] & {}
\end{tikzcd} \]
\item Strong confluence is expressed by the diagram
\[ \begin{tikzcd}
x \arrow[r] \arrow[d, swap, "{}"] & y_1 \arrow[d, dashed, "{?}"] \\
y_2 \arrow[r, dashed, swap, "{*}"] & {}
\end{tikzcd} \]
\item The diamond property is expressed by the diagram
\[ \begin{tikzcd}
x \arrow[r] \arrow[d, swap, "{}"] & y_1 \arrow[d, dashed, "{}"] \\
y_2 \arrow[r, dashed, swap, "{}"] & {}
\end{tikzcd} \]
\end{itemize}
\end{example}

\begin{lemma}
Let $\sSet{X,R}$ be a rewriting system. Then each of the following properties implies the next:
\begin{enumerate}
\item diamond property;
\item strong confluence;
\item confluence;
\item local confluence.
\end{enumerate}
\end{lemma}
\begin{proof}
$(1) \Rightarrow (2)$ Immediate as $R \subseteq R^?$ and $R\subseteq R^*$.

$(2) \Rightarrow (3)$ By \ref{confluenceEquivalents} it is enough to prove semi-confluence. First we observe the lemma
\begin{lemma*} The following diagrams are equivalent:
\[ \begin{tikzcd}
x \arrow[r] \arrow[d, "{}"] & y_1 \arrow[d, dashed, "{?}"] \\
y_2 \arrow[r, dashed, swap, "{*}"] & {z}
\end{tikzcd} \qquad\iff\qquad \begin{tikzcd}
x \arrow[r] \arrow[d, "{?}"] & y_1 \arrow[d, dashed, "{?}"] \\
y_2 \arrow[r, dashed, swap, "{*}"] & {z}
\end{tikzcd}. \]
\end{lemma*}
\begin{proof}[Proof of sublemma] \renewcommand{\qedsymbol}{$\dashv$}
The direction $\Leftarrow$ is immediate because $R\subseteq R^?$. For the other direction, take $x,y_1,y_2 \in X$ such that $xRy_1$ and $xR^?y_2$. If $xRy_2$, then the implication is immediate. If not, then $x=y_2$ and we can take $z = y_1$ and we have $y_2Rz$.
\end{proof}
By induction on RS-diagrams, we conclude from
\[ \begin{tikzcd}[ampersand replacement=\&]
{} \arrow[r] \arrow[d, "{?}"] \& {} \arrow[d, dashed, "{?}"] \\
{} \arrow[r,  dashed, "{*}"] \& {}
\end{tikzcd} \quad\iff\quad \begin{tikzcd}[ampersand replacement=\&]
{} \arrow[r] \arrow[d] \& {} \arrow[d, dashed, "{?}"] \\
{} \arrow[r,  dashed, "{*}"] \& {}
\end{tikzcd} \quad\implies\quad \begin{tikzcd}[ampersand replacement=\&]
{} \arrow[r] \arrow[d] \& {} \arrow[d, dashed, "{?}"] \arrow[r] \& {}  \\
{} \arrow[r,  dashed, "{*}"] \& {} \& {}
\end{tikzcd} \quad\implies\quad \begin{tikzcd}[ampersand replacement=\&]
{} \arrow[r] \arrow[d] \& {} \arrow[d, dashed, "{?}"] \arrow[r] \& {} \arrow[d, dashed, "{?}"] \\
{} \arrow[r,  dashed, "{*}"] \& {} \arrow[r,  dashed, "{*}"] \& {}
\end{tikzcd} \]
that $\begin{tikzcd}
{} \arrow[r, "{*}"] \arrow[d] & {} \arrow[d, dashed, "{?}"] \\
{} \arrow[r, dashed, "{*}"] & {}
\end{tikzcd}$. This implies $\begin{tikzcd}
{} \arrow[r, "{*}"] \arrow[d] & {} \arrow[d, dashed, "{*}"] \\
{} \arrow[r, dashed, "{*}"] & {}
\end{tikzcd}$, i.e.\ semi-confluence.

$(3) \Rightarrow (4)$ Immediate because $R\subseteq R^*$.
\end{proof}

\begin{proposition}[Newman's lemma]
Let $\sSet{X,R}$ be a terminating rewriting system. Then $X$ is confluent \textup{if and only if} $X$ is locally confluent.
\end{proposition}
\begin{proof}
TODO
\end{proof}

\section{Term rewriting}
\begin{definition}
A \udef{string rewriting system} or \udef{semi-Thue system} is a pair $\sSet{\Sigma, R}$ where
\begin{itemize}
\item $\Sigma$ is a set (the \udef{alphabet});
\item $R$ is a binary relation on $\Sigma^*$. The elements of $R$ are called \udef{(rewriting) rules}.
\end{itemize}
\end{definition}

\chapter{Languages}
\begin{definition}
A \udef{language} is a set of strings.
\end{definition}

\begin{definition}
Let $L$ be a language in an alphabet $A$. Then we define the \udef{Kleene closure} of the language $L$ as
\[ L^* \defeq \Closure_\concat(L) \cup \{\seq{}\}. \]
\end{definition}
Note that $A^* = \setbuilder{\seq{a}}{a\in A}^*$.

\section{Grammars}
\begin{definition}
A \udef{(formal) grammar} is a tuple $G = \sSet{\Sigma, N, R, S}$ where
\begin{itemize}
\item $\Sigma$ is a finite set, called the \udef{alphabet} or set of \udef{terminal symbols};
\item $N$ a finite set, disjoint from $\Sigma$, of \udef{nonterminal symbols};
\item $R$ is relation on $(\Sigma \uplus V)^*$ that is a finite set; it is also called the set of \udef{production rules};
\item $S\in N$.
\end{itemize}
\end{definition}

\subsection{Chomsky hierarchy}
\subsubsection{Regular}
\subsubsection{Context-free}
\subsubsection{Context-sensitive}
\subsubsection{Recursively enumerable}


\section{Automata}
\begin{definition}
An \udef{automaton} is a $5$-tuple $M = \sSet{\Sigma, Q, \delta, q_0, F}$, where
\begin{itemize}
\item $\Sigma$ is a finite set, called the \udef{input alphabet} of the automaton,
\item $Q$ is a set of \udef{states},
\item $\delta: Q\times \Sigma\to Q$ is a function, called the \udef{transition function},
\item $q\in Q$ is the \udef{start state}, and
\item $F\subseteq Q$ is the set of \udef{accept states} or \udef{final states}.
\end{itemize}
We call the automaton \udef{finite} if $Q$ is finite.

The automaton $M$ defines a function $e_M: \Sigma^* \to Q^*$ recursively by
\[ \begin{cases}
e_M(\seq{}) = \seq{q_0}, \\
e_M(u\concat \seq{x}) = e_M(u)\concat \delta(e(u)_{-1}, x) & (u\in \Sigma^*, x\in \Sigma).
\end{cases} \]

We say $M$ \udef{accepts} a string $u\in \Sigma^*$ if $e_M(u)_{-1} \in F$.

The set of all strings in $\Sigma^*$ that are accepted by the automaton is the language \udef{recognised} by $M$, or just the \udef{language of $M$}:
\[ L_M \defeq \setbuilder{u\in\Sigma^*}{e_M(u)_{-1} \in F}. \]
\end{definition}

\begin{lemma} \label{automatonExecutionLength}
Let $M = \sSet{\Sigma, Q, \delta, q_0, F}$ be an automaton and $u\in \Sigma^*$. Then $\len(e_M(u)) = \len(u)+1$.
\end{lemma}

\begin{proposition}
Let $M_1 = \sSet{\Sigma, Q_1, \delta_1, q_{0,1}, F_1}$ and $M_2 = \sSet{\Sigma, Q_2, \delta_2, q_{0,2}, F_2}$ be automata that accept the languages $L_{M_1}$ and $L_{M_2}$ in the same alphabet $\Sigma$. Define
\[ \delta = \curry_2^{-1}\Big(a\mapsto (\delta_1(-, a), \delta_2(-, a))\Big). \]
Then
\begin{enumerate}
\item $M_{\cup} = \sSet{\Sigma, Q_1\times Q_2, \delta, (q_{0,1}, q_{0,2}), (F_1\times Q_1) \cup (F_2\times Q_2)}$ is an automaton that recognises $L_{M_1}\cup L_{M_2}$;
\item $M_{\cap} = \sSet{\Sigma, Q_1\times Q_2, \delta, (q_{0,1}, q_{0,2}), F_1 \times F_2}$ is an automaton that recognises $L_{M_1}\cap L_{M_2}$.
\end{enumerate}
\end{proposition}

\subsection{State diagrams}
TODO. Double circle for accept states.

\subsection{Constructions}
\subsubsection{Changing initial state}
\begin{definition}
Let $M = \sSet{\Sigma, Q, \delta, q_{0}, F}$ be an automaton and $q\in Q$. Then $M|_{q}$ is the automaton $\sSet{\Sigma, Q, \delta, q, F}$, i.e.\ the same automaton except the initial state has been replaced by $q$.
\end{definition}

\begin{lemma} \label{automatonRunFactorisation}
Let $M = \sSet{\Sigma, Q, \delta, q_{0}, F}$ be an automaton and $x,y\in \Sigma^*$. Then
\[ e_M(x \concat y) = e_M(x)\concat \big(e_{M|_{q_x}}(y)[1:]\big), \]
where $q_x = e_M(x)_{-1}$.
\end{lemma}
\begin{proof}
Consider the functions $y\mapsto e_M(x \concat y)$ and $y\mapsto e_M(x)\concat e_{M|_{q_x}}(y)$. They satisfy the same recursion relation and thus are the same by \ref{stringRecursion}.
\end{proof}

\subsection{Non-deterministic automata}
\begin{definition}
A \udef{non-deterministic automaton} is a $5$-tuple $M = \sSet{\Sigma, Q, \delta, Q_0, F}$, where
\begin{itemize}
\item $\Sigma$ is a finite set of symbols, called the \udef{input alphabet} of the automaton,
\item $Q$ is a set of \udef{states},
\item $\delta: Q\times \Sigma \to \powerset(Q)$ is a function, called the \udef{transition function},
\item $Q_0\subseteq Q$ is the \udef{start state}, and
\item $F\subseteq Q$ is the set of \udef{accept states} or \udef{final states}.
\end{itemize}
We call the non-deterministic automaton \udef{finite} if $Q$ is finite.

The automaton $M$ defines a function $e_M: \Sigma^* \to \powerset(Q^*)$ recursively by
\[ \begin{cases}
e(\seq{}) = \setbuilder{\seq{q_0}}{q_0\in Q_0}, \\
e(u\concat \seq{x}) = \setbuilder{v\concat q}{v\in e(u), q\in \delta(v_{-1}, x)} & (u\in \Sigma^*, x\in \Sigma).
\end{cases} \]

We say $M$ \udef{accepts} a string $u\in \Sigma^*$ if $\exists r\in e_M(u): r_{-1} \in F$.

The set of all strings in $\Sigma^*$ that are accepted by the automaton is the language \udef{recognised} by $M$, or just the \udef{language of $M$}:
\[ L_M \defeq \setbuilder{u\in\Sigma^*}{\exists r\in e_M(u): r_{-1} \in F}. \]
\end{definition}

\begin{lemma} \label{automatonAsNDAutomaton}
Let $M = \sSet{\Sigma, Q, \delta, q_0, F}$ be an automaton. Consider the non-deterministic automaton $M' = \sSet{\Sigma, Q, \delta', Q_0', F}$, where
\begin{itemize}
\item $Q_0' = \{q_0\}$; and
\item $\delta' = \{\delta(-)\}$.
\end{itemize}
Then
\begin{enumerate}
\item $e_{M} = \{e_{M'}(-)\}$;
\item $M$ and $M'$ accept the same language.
\end{enumerate}
\end{lemma}
\begin{proof}
Point (2) follows straight from point (1) and point (1) is easy to prove by induction on input string length.
\end{proof}

\begin{proposition}
Let $M_1 = \sSet{\Sigma, Q_1, \delta_1, Q_{0,1}, F_1}$ and $M_2 = \sSet{\Sigma, Q_2, \delta_2, Q_{0,2}, F_2}$ be non-deterministic automata that accept the languages $L_{M_1}$ and $L_{M_2}$ in the same alphabet $\Sigma$.
Then
\begin{enumerate}
\item $M_{\cup} = \sSet{\Sigma, Q_1\sqcup Q_2, (\delta_1 \bbslash \delta_2), Q_{0,1}\sqcup Q_{0,2}, F_1 \sqcup F_2}$ is a non-deterministic automaton that recognises $L_{M_1}\cup L_{M_2}$;
\item $M_\star = \sSet{\Sigma, (Q_1\setminus F_1) \sqcup (F_1\times Q_{0,2}) \sqcup (Q_2\setminus Q_{0,2}), \delta', Q_{0,1}, F_2}$, where
\[ \delta': (q,s)\mapsto \begin{cases}
\big(\delta_1(q,s)\setminus F_1\big) \sqcup \Big(\big(\delta_1(q,s)\cap F_1\big)\times Q_{0,2}\Big) & (q\in Q_1\setminus F_1) \\
\big(\delta_1(\proj_1(q),s)\setminus F_1\big) \sqcup \Big(\big(\delta_1(\proj_1(q),s)\cap F_1\big)\times Q_{0,2}\Big) \sqcup \delta_2\big(\proj_2(q), s\big) & (q\in F_1\times Q_{0,2}) \\
\delta_2(q,s) & (q\in Q_2\setminus Q_{0,2})
\end{cases} \]
is a non-deterministic automaton that recognises $L_{M_1}\concat L_{M_2}$.
\end{enumerate}
\end{proposition}

TODO: define (better syntax!!!!!!) + picture gluing of automata.

\begin{proposition}
Let $M = \sSet{\Sigma, Q, \delta, Q_{0}, F}$ be a non-deterministic automata that accept the languages $L_{M}$.
Then consider the non-deterministic automaton $M' = \sSet{\Sigma, Q', \delta', Q_{0}, F'}$, where
\begin{itemize}
\item $Q' = Q_0 \sqcup (Q\setminus F) \sqcup (F\times Q_0)$;
\item $\delta': (q,s) \mapsto \begin{cases}
\big(\delta(q,s)\setminus F\big) \sqcup \Big(\big(\delta(q,s)\cap F\big) \times Q_0\Big) & (\text{$q\in Q_0$ or $q\in Q\setminus F$}) \\
\begin{multlined}\big(\delta(\proj_1(q),s)\setminus F\big) \sqcup \Big(\big(\delta(\proj_1(q),s)\cap F\big) \times Q_0\Big) \vspace{-1em} \\ \cup \big(\delta(\proj_2(q),s)\setminus F\big) \sqcup \Big(\big(\delta(\proj_2(q),s)\cap F\big) \times Q_0\Big) \end{multlined}& (q\in F\times Q_0);
\end{cases}$
\item $F' = Q_0 \sqcup (F\times Q_0)$.
\end{itemize}
Then $M'$ recognises $L_{M}^*$.
\end{proposition}
Note the use of $\cup$ vs $\sqcup$.



\subsection{Finite automata}
\begin{definition}
A language is called a \udef{regular language} if it is recognised by a finite automaton.
\end{definition}

\begin{proposition}
Let $L$ be a language in an alphabet $\Sigma$. Then $L$ is recognised by a finite automaton \textup{if and only if} it is recognised by a finite non-deterministic automaton.
\end{proposition}
\begin{proof}
The direction $\Rightarrow$ is immediate from \ref{automatonAsNDAutomaton}.

For the converse, take a finite non-deterministic automaton $M = \sSet{\Sigma, Q, \delta, Q_0, F}$. Consider the automaton $M' = \sSet{\Sigma, \powerset{Q}, \delta', Q_0, F'}$, where
\begin{itemize}
\item $\delta': \powerset{Q} \times \Sigma \to \powerset{Q}: (A,s) \mapsto \bigcup_{q\in A}\delta(q, s)$;
\item $F' = \setbuilder{A\in \powerset(Q)}{A\mesh F}$.
\end{itemize}
Then we need to prove $L_{M} = L_{M'}$. Indeed we can prove by induction that, for all $u\in \Sigma^*$,
\[ \setbuilder{q_{-1}}{q\in e_M(u)} = e_{M'}(u)_{-1}. \]
Call this set $A$. We have that $M$ accepts $u$ iff $F\mesh A$ and $M'$ accepts $u$ iff $A\in F'$. By definition of $F'$, these cases are the same.
\end{proof}


\subsubsection{The pumping lemma}
\begin{theorem}[Pumping lemma]
Let $L$ be a regular language. Then there exists $p\in \N$ such that for all $s \in L$, we can write $s = x\concat y \concat z$ with
\begin{enumerate}
\item $x\concat y^k \concat z \in L$ for all $k\in\N$;
\item $\len(y) \geq 1$;
\item $\len(x\concat y) \leq p$.
\end{enumerate}
\end{theorem}
We also allow $k=0$, so $x\concat z$ must be an element of $L$.
\begin{proof}
Let $M = \sSet{\Sigma, Q, \delta, q_0, F}$ be a finite automaton that recognises $L$. Set $p = \#Q$. If $\len(s) \leq p$, then we can set $x=\seq{}, y= s$ and $z=\seq{}$.

Now assume $\len(s) > p$ and consider $e_M(s)$, which is a string in $Q$. By \ref{automatonExecutionLength}, we have
\[ \len(e_M(s)) = \len(s)+1 > p +1 = \#Q+1. \]
By \ref{stringPigeonholePrinciple} there must be a state in $e_M(s)[0:\#Q+1]$ that repeates. Let $k_1, k_2$ be the two different indices of this state in $e_M(s)$.

Then we may set $x = s[0:k_1]$, $y = s[k_1:k_2]$ and $z = s[k_2:]$.

Point (3) is satisfied as $\len(x\concat y) = k_2 \leq \#Q = p$.

Point (2) is satisfied as $k_1\neq k_2$.

For point (1), define the automaton $M' = \sSet{\Sigma, Q, \delta, e_M(x)_{-1}, F}$ and $M^{\prime\prime} = \sSet{\Sigma, Q, \delta, e_M(x\concat y)_{-1}, F}$.
It is enough to prove that
\[ e_M(x\concat y^k \concat z) = e_M(x)\concat \big(e_{M'}(y)[1:]\big)^k \concat \big(e_{M^{\prime\prime}}(z)[1:]\big). \]
We use \ref{automatonRunFactorisation}. We then only need to prove that $\big(e_{M'}(y^k)[1:]\big) = \big(e_{M'}(y)[1:]\big)^k$. This is evident by induction on $k$, using \ref{automatonRunFactorisation}.
\end{proof}

\begin{example}
The following languages are not regular:
\begin{itemize}
\item $\setbuilder{\seq{0}^n\seq{1}^n}{n\geq 0}$;
\item $\setbuilder{u\in \{0, 1\}^*}{\text{$u$ contains an equal number of $1$s and $0$s}}$;
\item $\setbuilder{u\concat u}{u\in \{0,1\}^*}$;
\item $\setbuilder{\seq{1}^{n^2}}{n\in \N}$;
\item $\setbuilder{\seq{0}^i\seq{1}^j}{i>j \in \N}$. We prove this by contradiction. Assume $p$ is the pumping length and consider $\seq{0}^{p+1}\seq{1}^p$, which is a string in the language. Then $y$ must consist of a non-empty string of zeros. Now the string $xy^0z = xz$ must be in the language by the pumping lemma. However in this case $xz = \seq{0}^l\seq{1}^j$ where $l\leq j$, which means that $xz$ is not an element of the language. This is a contradiction.
\end{itemize}
\end{example}